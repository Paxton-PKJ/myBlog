---
title: 408操作系统—3.内存管理
slug: memory-management-2dqfq
url: /post/memory-management-2dqfq.html
date: '2024-05-12 20:01:00+08:00'
lastmod: '2024-06-13 10:56:44+08:00'
toc: true
tags:
  - '408'
  - 操作系统
categories:
  - 提桶跑路笔记
keywords: 408,操作系统
isCJKLanguage: true
---





* 内存管理

  * 内存管理的概念

    * 内存管理概述

      * 什么是内存管理
      * 内存管理的功能
    * 程序的链接与装入过程

      * 物理地址
      * 逻辑地址
      * 相对地址
      * 绝对地址
      * 编译
      * 链接

        * 静态链接
        * 装入时动态链接
        * 运行时动态链接
      * 装入

        * 绝对装入
        * 可重定位装入
        * 动态运行时装入
    * 进程的内存映像
    * 内存保护
    * 内存共享
    * 内存分配与回收
  * 内存管理方法

    * 连续分配管理方式
    * 基本分页存储管理
    * 基本分段存储管理
    * 段页式存储管理
* 虚拟内存管理

  * 虚拟内存基本概念
  * 请求分页管理方式
  * 页框分配
  * 页面置换算法
  * 抖动和工作集
  * 内存映射文件
  * 虚拟存储器性能影响因素

## 内存管理

### 内存管理的概念

#### 内存管理概述

* **什么是内存管理**

  操作系统对内存的<u>划分和动态分配</u>
* **内存管理的功能**

  1. **内存空间的分配与回收**

     由 OS 完成主存储器空间的分配和管理
  2. **地址转换**

     将程序的逻辑地址转换为内存种的物理地址
  3. **内存空间的扩充**

     利用虚拟存储技术从逻辑上扩充内存
  4. **内存共享**

     允许多个进程访问内存同一部分
  5. **存储保护**

     保证多道作业在各自存储空间运行，互不干扰

#### 程序的链接与装入过程

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202405131536939.png)​

* **物理地址**：实际的硬件内存地址，由内存芯片直接访问
* **逻辑地址**：程序员在编写程序时使用的地址，由 CPU 生成，并通过 MMU 转换为物理地址
* **相对地址**：基于某个基准点的偏移量，需要与基准点结合来表示实际绝对地址
* **绝对地址**：内存中的一个固定位置，是一个具体的固定数值，直接指向内存的一个存储单元

创建进程首先需要将程序和数据装入内存，将用户源程序变为可以在内存中执行的程序

1. **编译**

   由编译程序将用户源代码编译成若干<u>目标模块</u>

   **目标模块**：由<u>源代码编译而来</u>，还未被链接为最终可执行文件的**<u>中间文件</u>**，通常为<u>机器代码的二进制表示</u>
2. **链接**

   由链接程序将目标模块和所需库函数链接，形成完整<u>装入模块</u>

   **装入模块**：已经经过编译和链接处理，可以被操作系统装入内存并执行的**<u>可执行文件</u>**。装入模块通常包含了所有必要的代码、数据和资源，以便在运行时正确执行

   1. **静态链接**

      链接成完整装入模块后<u>不再拆开</u>

      由于编译后的目标模块都是相对地址，链接为装入模块时相对地址需要修改

      每个目标模块的外部调用符号也变化为相对地址
   2. **装入时动态链接**

      一组目标模块在装入内存时进行的链接操作，目标模块包含对动态链接库（DLL 或共享库）的引用，操作系统在加载程序时解析这些引用并加载相应的库

      便于修改和更新，可以实现目标模块（库文件）的共享，但增加加载时间
   3. **运行时动态链接**

      程序运行中需要用到某目标模块时再链接，未使用的目标模块都不会调入内存和形成装入模块

      能够加快程序装入过程，节省内存，需要额外代码管理库的加载和卸载
3. **装入**

   装入程序将装入模块装入内存运行

   1. **绝对装入**

      <u>只适用于单道程序环境</u>

      编程时就将物理地址计算好，程序中的逻辑地址和实际内存地址完全相同
   2. **可重定位装入**

      也称为<u>静态重定位装入</u>，装入时根据实际情况调整程序的地址，将程序加载到合适的内存位置，把程序中的相对地址转换为物理地址

      必须一次分配所有所需内存，运行期间不能移动也不能再次申请内存空间，避免地址冲突

      ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202405131600362.png)​
   3. **动态运行时装入**

      也称为<u>动态重定位装入</u>

      可以装入部分需要执行的代码分配相应内存地址，在程序运行期间根据动态需要申请内存，且申请的内存区<u>可以不连续</u>

      因此每分配一段内存地址都需要一个重定位寄存器，其中存放装入模块的起始位置

      通常与运行时动态链接结合发生

      ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202405131600032.png)​

#### 进程的内存映像

程序调入内存运行时，构成进程的内存映像

* **代码段**

  程序的二进制代码，只读，共享
* **数据段**

  包含全局变量和静态变量
* **bss 段**

  包含未初始化的全局变量和静态变量
* 进程控制块（见2️⃣进程与线程）
* **堆**

  动态内存分配，存放动态分配变量，通过调用 `malloc` ​函数动态向高地址分配空间
* **栈**

  实现函数调用和存储局部变量，从用户空间最大地址往低地址方向增长

```c
int global_var = 10;  // 数据段

int main() {
    static int static_var = 20;  // 数据段
    int local_var = 30;  // 栈
    int *heap_var = (int *)malloc(sizeof(int));  // 堆
    *heap_var = 40;
}
```

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202406121026746.png)​

#### 内存保护

确保每个进程都拥有单独的内存空间，有以下两种方法：

1. 在 CPU 中设置⼀对**上下限存储器**，存放用户进程在主存中的下限和上限地址，判断 CPU 访问的地址是否越界
2. **重定位寄存器**（基地址寄存器）和**界地址寄存器**（限长寄存器）进行越界检查

   前者存放进程<u>起始物理地址</u>

   后者存放<u>进程最大逻辑地址</u>，即进程的内存段的长度（或界限）。它定义了进程可以访问的内存范围的大小。

   1. **逻辑地址生成**：进程生成一个逻辑地址用于访问内存
   2. **越界检查**：在将逻辑地址转换为物理地址之前，系统会进行越界检查：

      * 检查逻辑地址是否小于界地址寄存器的值（即逻辑地址是否在合法范围内）
      * 如果逻辑地址大于或等于界地址寄存器的值，则发生<u>越界访问</u>，系统会触发异常或错误处理机制
   3. **地址转换**：如果逻辑地址通过了越界检查，系统会将逻辑地址加上重定位寄存器的值，生成实际的物理地址
   4. **内存访问**：使用生成的物理地址进行内存访问

   仅操作系统可以加载以上两个寄存器，不允许用户更改

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202406121035614.png)​

#### 内存共享

只有只读区域才可以共享，

纯代码/可重入代码=不能修改的代码，不属于临界资源

实际执行时，每个进程配有局部数据区，可能改变的部分将复制到数据区，只对各自的私有数据区内存进行修改，共享代码不改变

#### 内存分配与回收

1. **连续分配**

   1. **单一连续分配**

      单道发展到多道 OS↓
   2. **固定分区分配**

      为了适应大小不同的程序 ↓
   3. **动态分区分配**

      更好提高内存利用率 ↓
2. **不连续分配**

   1. **分段存储管理**

      为了满足用户在编程和使用方面的要求
   2. **分页存储管理**
   3. **段页存储管理**

### 内存管理方法

#### 连续分配

为用户分配一个连续的内存空间

内部碎片：当程序小于固定分区大小时，也要占用一个完整的内存分区，这样分区内部就存在空间浪费

1. **单一连续分配**

   * **定义**

     内存分为系统区和用户区

     系统区仅 OS 使用，用户区由一道程序独占
   * **优点**

     1. 简单，无外部碎片
     2. 无需进行内存保护
   * **缺点**

     1. 只能用于单用户单任务系统
     2. 存在内部碎片，存储器利用率极低
2. **固定分区分配**

   * **定义**

     内存划分为若干固定大小分区，每个分区只有一道作业
   * **优点**

     * 简单
   * **缺点**

     1. 程序太大可能放不进任何分区，存在内部碎片
     2. 不能实现多进程共享一个主存区，存储空间利用率低
3. **动态分区分配**

   * **概念**

     也称<u>可变分区分配</u>，进程转入内存时，根据进程的实际需要，动态地分配内存；动态分区是在作业<u>装入时动态建立</u>的，装入时使用多少，分区大小就是多少

     ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202406130919442.png)​

     随时间推移容易出现外部碎片

     外部碎片：存在于所有内存分区的外部，区别于内部碎片
   * **内存回收方法**

     1. 回收区与插入点的<u>前一空闲分区相邻</u>，此时将这两个分区<u>合并</u>，并修改前一分区表项的大小为两者之和
     2. 回收区与插入点的<u>后一空闲分区相邻</u>，此时将这两个分区合并，并修改后一分区表项的始址和大小
     3. 回收区同时与插入点的<u>前、后两个分区相邻</u>，此时将这三个分区合并，修改前一分区表项的大小为三者之和，并取消后一分区表项
     4. 回收区没有相邻的空闲分区，此时应该为回收区新建一个表项，填写始址和大小，并插入空闲分区链
   * **基于顺序搜索的分配算法**

     1. **首次适应算法**

        按<u>**地址递增**</u>​<u>的次序排列</u>，分配第一个能满足大小的空闲分区

        保留了高地址部分大空闲分区

        低地址部分产生大量碎片，增加查找开销
     2. **邻近适应算法(循环首次适应算法)**

        与前者相比，从上次查找结束的位置继续开始查找

        导致高地址部分无大空闲分区，比前者适应性更差
     3. **最佳适应算法**

        按**<u>容量递增</u>**​<u>次序排列</u>，分配第一个能满足大小的空闲分区

        将留下越来越多难以利用的内存碎片，**<u>产生外部碎片最多</u>**
     4. **最坏适应算法**

        按<u>**容量递减**</u>​<u>次序排列</u>，分配当前最大的空闲分区

        将导致没有大分区可用，性能也很差
   * **基于索引搜索的分配算法**​

     根据大小对空闲分区分类，每个分类设立一个空闲分区链，用一个索引表管理空闲分区链

     1. **快速适应算法**

        找到能容纳的最小空闲分区链表，取出链表第一块空间

        查找效率高，不产生内部碎片

        回收分区需要有效合并分区，系统开销大，复杂
     2. **伙伴系统**

        所有分区大小均为 $2^k$，需要分配大小为 n 的分区时 $(2^{i-1}<n\leqslant2^{i})$，在大小为 $2^i$ 的空闲分区链中分配

        耗尽则在 $2^{i+1}$ 中分配，若有，拆分该分区为两个 $2^i$ 大小分区，一个分配，另一个加入前一空闲分区连，称为一对伙伴

        以此类推，回收时，也可能需要对伙伴分区合并
     3. **哈希算法**

        构建以空闲分区大小为关键字的哈希表，记录空闲分区链的头指针

        由所需分区大小，在哈希表中由哈希函数查找到头指针位置，得到空闲分区链表

连续分配方式中，不管如何分配，只要没有连续的足够大小的空间即无法分配

因此有**非连续分配**方式，由分区大小是否固定分为**分页**与**分段**

分页中由<u>是否需要整个作业装入内存</u>中分为**基本分页**和**请求分页**

#### 基本分页存储管理

#### 基本分段存储管理

#### 段页式存储管理

‍

---
title: 408操作系统—5.输入输出(IO)管理
slug: 408-operating-system-5-input-and-output-io-management-z2nm1kv
url: /post/408-operating-system-5-input-and-output-io-management-z2nm1kv.html
date: '2024-08-02 15:22:35+08:00'
lastmod: '2024-08-04 21:29:42+08:00'
toc: true
tags:
  - '408'
  - 操作系统
categories:
  - 提桶跑路笔记
keywords: 408,操作系统
isCJKLanguage: true
---





## I/O 管理概述

### I/O 设备

#### I/O 设备分类

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408012040707.png)​

#### I/O 接口（设备控制器）

CPU 与设备之间的接口

* **主要功能**

  * 接受和识别 CPU 发来的命令
  * 数据交换（设备和控制器的数据交换 + 控制器和主存数据交换）
  * 标识和报告设备的状态
  * 地址识别；数据缓冲；差错控制
  * <u>设备控制器不属于操作系统范畴，它是属于硬件</u>
* **组成**

  1. **设备控制器 &amp; CPU**

     * **数据线**

       传输读写数据、控制信息、状态信息
     * **地址线**

       传送要访问 I/O 接口中的寄存器编号
     * **控制线**

       发出读写控制信号

     CPU 通过<u>控制线发出命令</u>，通过<u>地址线指明要操作的设备</u>，通过<u>数据线来输入输出数据</u>
  2. **设备控制器 &amp; 设备**

     一对多，每个接口都可以传输<u>数据、控制和状态</u>三种类型信号，用于实现<u>控制器和设备之间通信</u>
  3. **I/O 逻辑**

     * 负责接受和识别 CPU 的命令
     * 根据命令对相应设备发送命令
     * 实现设备控制功能

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408012059865.png)​

#### I/O 接口类型

1. **按数据传输方式**

   * **并行接口**：一个字节或一个字的所有位同时传送
   * **串行接口**：一位一位传送
2. **按主机控制设备的方式**

   * **程序查询接⼝**
   * **中断接⼝**
   * **DMA接⼝**
3. **按功能选择的灵活性**

   * **可编程接⼝**
   * **不可编程接⼝**

#### I/O 端口及其编址

指设备控制器中<u>可被 CPU 直接访问的</u>​<u>**寄存器**</u>

1. 分类

   * **数据寄存器**

     CPU 向 I/O 设备<u>写入需要传输的数据</u>
   * **状态寄存器**

     告知 CPU 正在工作或已完成

     <u>正在工作时，CPU 发送命令无效</u>

     工作完成，状态标记已完成  
     CPU 才能发送下一个字符和命令
   * **控制寄存器**

     由 cpu 写入以<u>改变设备运行模式或启动命令</u>
2. **编址**

   1. **独立编址**

      每个端口分配一个端口号

      端口地址空间和主存地址空间之间<u>独立</u>

      操作系统使用专门I/O指令才能访问端口

      * **优点**

        专用指令程序清晰

        硬件实现简单，只需要少量地址线，寻址速度快
      * **缺点**

        指令少，<u>程序灵活性差</u>

        两组读写系统<u>增加控制复杂性</u>
   2. **统一编址**

      又称内存映射 I/O，主存地址提供一部分用于访问 I/O 端口

      * **优点**

        无需专用指令，访存指令即可，<u>程序简单</u>

        端口拥有较大编址空间，访存保护由虚拟存储管理系统实现
      * **缺点**

        主存可用容量变小

        硬件实现复杂，全部地址线参与译码

### I/O 控制方式

<u>控制设备和主机</u>之间的数据传送

发展宗旨：<u>减少 CPU 对 I/O 控制的干预</u>

#### 程序直接控制方式

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202409202200330.png)​

1. **独占查询**

    设备启动，CPU就一直持续查询接口状态，100%的时间用于I/O操作

    此时外设和CPU<u>完全串行工作</u>
2. **定时查询**

    CPU周期性地查询接口状态，总等到条件满足才进行一个数据的传送  
    传送完成后返回到用户程序

    时间间隔<u>与设备的数据传输速率有关</u>

<u>实现简单</u>，但 CPU 大部分时间都在等待完成，利用率低

CPU <u>未采用中断机构</u>，I/O 设备无法报告已完成，CPU 只能主动询问

#### 中断驱动方式

允许 I/O 设备发出中断请求，在允许响应的情况下，CPU暂时中止任务并向设备控制器发出一条 I/O 指令后继续其他工作

CPU 和设备并行工作，CPU 效率提升

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202409202209421.png)​

设备和内存交换<u>数据必须经过 CPU 寄存器</u>，效率低

此方式<u>以字节为单位交换数据</u>，对于<u>块设备效率极低</u>

#### DMA 方式（直接存储器存取）

在 <u>I/O 设备和内存之间</u>开辟直接数据交换通路，完全由硬件组成

* **特性**

  1. 基本传送单位为<u>数据块</u>
  2. 数据<u>不再经过 CPU</u>
  3. 只有<u>开始传送和传送结束时</u>需要 CPU 干预
  4. 适用于高速设备大批量数据传送
  5. 中断仅作用于传输中断以及传输成功的处理
* **DMA控制器功能**

  1. 接收外设发出的DMA请求，并向CPU发出总线请求
  2. CPU响应此总线请求，发出总线响应信号，<u>接管总线控制权</u>，进⼊DMA操作周期
  3. 确定传送数据的主存单元地址及⻓度，并⾃动修改主存地址计数和传送⻓度计数
  4. 规定数据在主存和外设间的传送⽅向，发出读写等控制信号，执⾏数据传送操作
  5. 向CPU报告DMA操作结束
* **DMA控制器组成**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240921093755-ygl4m3k.png)​

  1. **主存地址计数器**

      存放要交换数据的主存地址

      传送前记录起始地址，开始传送后每次增加上条地址长度
  2. **传送⻓度计数器**

      记录传送数据的总⻓度

      传送前记录总字数，每传送一个字-1直到0
  3. **数据缓冲寄存器**

      暂存每次传送的数据

      与主存交换取决字长，与设备交换单位各有可能
  4. **DMA请求触发器**

      每当I/O设备准备好数据后，给出⼀个控制信号，使DMA请求触发器置位
  5.  **“控制/状态”逻辑**

      由控制和时序电路及状态标志组成

      ⽤于指定传送⽅向，修改传送参数，并对DMA请求信号、CPU响应信号进⾏协调和同步
  6. **中断机构**

      当⼀个数据块传送完毕后触发中断机构，向CPU提出中断请求
* **DMA传送方式**

  当I/O设备和CPU同时访问主存时，可能发⽣冲突

  1. **停止CPU访存**
  2. **周期挪用**

      I/O访存优先级⾼于CPU访存，因为I/O不⽴即访存就可能会丢失数据，此时由I/O设备挪⽤⼏个存取周期

      CPU已在访存，等待本次结束后再挪用

      同时请求访存，优先I/O
  3. **交替访存**

      适⽤于CPU⼯作周期⽐主存存取周期⻓的情况
* **工作流程**

  1. **预处理**

      由CPU完成⼀些必要的准备⼯作
  2. **数据传送** 

      以单字节（或字）为基本单位  
      以数据块为基本单位（此时通过循环实现）
  3. **后处理** 

      DMAC向CPU发出中断请求，CPU执⾏中断服务程序做DMA结束处理

      * 校验送⼊主存的数据是否正确
      * 测试传送过程中是否出错（错误则转诊断程序）
      * 决定是否继续使⽤DMA传送其他数据等

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202409211002696.png)​

#### 通道控制方式

I/O 通道是一种特殊的处理机，执行通道指令

* **特性**

  1. CPU、通道、I/O 设备并行工作，资源利用率高
  2. 实现复杂，需要<u>专门 I/O 通道处理器</u>
  3. 一个通道可以控制<u>多台设备与内存数据交换</u>
* **工作流程**

  1. CPU 向通道发出 I/O 指令，指明通道程序在内存位置和要访问的设备
  2. 通道程序执行，完成 I/O 任务后，发出中断请求
* **通道与一般处理机区别**

  指令单一，没有内存，<u>与 CPU 共享内存</u>
* **通道与 DMA 区别**

  通道传输的<u>数据块大小和传输的内存位置</u>由通道控制

  通道可以同时<u>控制多台设备</u>与内存的数据交换

#### 方式比较

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408021407539.png)​

### I/O 软件层次结构

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408021424982.png)​

1. **用户层软件**

   实现用户交互接口，必须通过系统调用获取服务

   如发送 read 命令
2. **设备独立性软件**

   * **设备独立性**

     也称设备无关性

     应用所用设备不局限于具体物理设备，从而引入逻辑设备和物理设备概念

     应用程序使用逻辑设备名进行请求，系统将逻辑设备名映射为物理设备名

     增加设备分配灵活性，易于实现 I/O 重定向
   * **软件功能**

     1. **执行所有设备的公有操作**

        设备分配回收、设备名映射、设备保护、缓冲管理、提供大小统一逻辑块、屏蔽设备交换单位和速率差异
     2. **向用户层提供统一接口指令**

        文件系统管理（如文件的创建、删除、读写等操作）
3. **设备驱动程序**

   * 提供与具体设备相关的 I/O 操作接口
   * 直接与硬件设备交互，处理设备特定的命令和状态，解析上层命令为指令
   * 实现设备初始化、配置和中断处理等功能
4. **中断处理程序**

   * 处理来自硬件设备的中断信号
   * 在中断发生时，保存当前的 CPU 状态，执行相应的中断服务例程
   * 通知设备驱动程序已完成相应的 I/O 操作
5. **硬件**

---

**各层次处理过程**

1. 用户需要<u>读取设备内容</u>，通过操作系统提供的 <u>read 命令接口</u>，经过**用户层**
2. 此时使用的通用接口，是每个设备都可以响应的统一命令，经过**设备独立层**进行<u>解析，然后交往下层</u>
3. 不同设备对 read 命令的行为有所不同。需要针对不同的设备，**设备驱动层**将 <u>read 命令解析成不同的指令</u>
4. 命令解析完毕后，需要<u>中断正在运行的进程，转而执行 read 命令</u>，这就需要**中断处理程序**
5. 命令真正抵达**硬件设备**，硬件设备的控制器<u>按照上层传达的命令操控硬件设备</u>，完成相应的功能

### 应用程序 I/O 接口

#### I/O 接口分类

1. **字符设备接口**

   * 用于访问字符设备，如键盘、鼠标、串口设备等
   * 数据按字符流的方式进行读写操作，设立**字符缓冲区**读写字符
   * 通常不支持随机访问，只能<u>顺序读写，传输速率低</u>
   * 输入输出通常采用<u>中断驱动</u>
   * 属于独占设备，提供打开、关闭操作实现<span data-type="text" id="">互斥共享</span>
2. **块设备接口**

   * 用于访问块设备，如<u>硬盘、光驱</u>等
   * 数据以<u>固定大小的块</u>进行读写操作
   * 支持随机访问，可以直接读取或写入特定的块，速度高，可寻址
   * 将上层传来的逻辑抽象命令转化为设备能识别的低层具体操作
   * 磁盘设备 I/O 常用 <span data-type="text" id="">DMA方式</span>
3. **网络设备接口**

   * 用于网络通信，支持数据包的发送和接收
   * 提供连接管理、数据传输、错误处理等功能
   * 支持多种网络协议，如 TCP、UDP 等
   * 网络套接字接口如 socket

#### 阻塞和非阻塞 I/O

- **阻塞 I/O**

  * **工作原理**

    1. 应用程序调用 I/O 函数（如 read、recv）
    2. 如果数据不可用，调用会阻塞，应用程序进入等待状态
    3. 一旦数据可用，I/O 操作完成，函数返回，应用程序继续执行
  * **优点**

    * <u>编程简单</u>，逻辑清晰
    * 适用于<u>不需要高并发处理</u>的场景
  * **缺点**

    * 当等待 I/O 操作完成时，<u>CPU 资源会被浪费</u>
    * <u>不适用于高并发场景</u>，可能导致性能瓶颈

* **非阻塞 I/O**

  * **工作原理**

    1. 应用程序调用非阻塞 I/O 函数（如 read、recv）并立即返回
    2. 如果数据不可用，函数<u>返回一个错误或特殊值</u>，表示数据未准备好
    3. 应用程序可以使用<u>轮询或事件通知机制</u>来检查数据是否可用
  * **优点**

    * 可以提高系统的并发处理能力和 <u>CPU 利用率</u>
    * 适用于<u>需要高并发处理</u>的场景，如网络服务器、实时系统等
  * **缺点**

    * <u>编程复杂度较高</u>，需要处理数据不可用的情况
    * 可能需要使用轮询或事件通知机制，<u>增加了编程难度，轮询将占用 CPU 时间</u>

## 设备独立性软件

### 设备独立性软件

### 高速缓存与缓冲区

#### 磁盘高速缓存（Disk Cache）

用于<u>提高磁盘I/O速度</u>，利用内存空间暂存磁盘中盘块信息

<u>逻辑上属于磁盘，物理上属于内存</u>

1. 内存单独使用<u>固定大小</u>空间作为缓存区
2. <u>未利用的全部内存</u>作为缓冲池

#### 缓冲区（Buffer）

* **引入目的**

  1. 缓和CPU与I/O设备间<u>速度不匹配</u>的矛盾
  2. 减少对CPU的<u>中断频率</u>，放宽对CPU中断响应时间的限制
  3. 解决基本<u>数据单元大小</u>（数据粒度）不匹配的问题
  4. 提高CPU和I/O设备之间的<u>并行性</u>
* **实现方法**

  1. 硬件缓冲器，成本高非必要不采用
  2. **内存缓冲区**

#### 缓冲技术分类

* **T时间**：磁盘——>缓冲区
* **M时间**：缓冲区——>用户
* **C时间**：CPU处理一块数据的时间

##### 单缓冲

通常为一个块

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240804105333-q4oxk1t.png)​

‍

<u>T、C可以并行进行</u>  

缓冲区为共享资源，互斥，要么输入要么读取，因此缓冲区冲满才能从缓冲区读取，<u>即M时间结束后才能进行下一个T时间</u>

1. **T &gt; C**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041056096.png)​
2. **T &lt; C**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041056936.png)​

<u>处理一块数据的时间为</u>​<u>$\max(C,T)+M$</u>

##### 双缓冲

先输入缓冲1，再输入缓冲2，CPU处理完1之后若2满接着处理2

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041103810.png)​

此时CMT并行

* **T &gt; C+M**

  即 传输时间和处理时间 快于 输入时间

  以至于<u>处理完一个块时下一个还没好，即下图M+C时刻</u>

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041108616.png)​
* **T &lt; C+M**

  当2T < 2M+C时，传输M和处理C不间断，即图示

  T时刻下一块准备好了，M+C时刻才处理完本块

  即<u>处理完一个块时，下一个块已经等着处理了</u>

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041110683.png)​

因此，平均时间为$\max(C+M,T)$

T和M+C速度基本匹配时效果最佳

##### 循环缓冲

多个大小相同缓冲区组成循环缓冲区，橙色满绿色空

<u>需要存入缓冲区，向in指针指向的冲入，移动in到下一个空缓冲区</u>

<u>需要取出缓冲区，从out指针指向的读取，移动out到下一个满缓冲区</u>

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041129430.png)​

##### 缓冲池

数据结构和操作函数组成的管理机制，用于管理多个缓冲区，多个进程共享使用

* **缓冲区按使用状况分为**

  1. 空缓冲队列：空缓冲区链接
  2. 输入队列：装满输入数据缓冲区链接
  3. 输出队列：装满输出数据缓冲区链接
* **缓冲池按功能分为**

  1. **收容输入**数据（hin）
  2. **提取输入**数据（sin）
  3. **收容输出**数据（hout）
  4. **提取输出**数据（sout）

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041159799.png)​

#### 高速缓存与缓冲区对比

|||高速缓存|缓冲区|
| -----------------------------------| :--------------------: | :-----------------------------------------------------------------------------------------| :-------------------------------------------------------------------------------|
|相同点||都介于高速设备和低速设备之间||
|区别|存放数据|低速设备上某些数据的复制数据<br /><br />即高速缓存上有的，低速设备上面必然有<br />|低速设备传递给高速设备的数据（或相反）<br /><br />不一定有备份<br />|
||目的|存放高速设备经常访问的数据<br /><br />若数据不在高速缓存中，则高速设备就需要从低速设备取得数据<br />|高速设备和低速设备的通信都要经过缓冲区<br /><br />高速设备永远不会直接去访问低速设备<br />|

### 设备分配与回收

根据用户的I/O请求分配所需设备，原则上要充分发挥设备，尽可能忙碌，避免死锁

#### 设备分配的数据结构

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041603302.png)​

1. **设备控制表（DCT）**

    <u>一个设备对应一个DCT</u>，表项为<u>设备属性</u>

    1. **设备类型**
    2. **设备标识符**：物理设备名
    3. **设备状态**：忙/闲，空闲即“设备回收”
    4. **指向控制器表的指针**
    5. **重复执行次数/时间**：达到该限制则I/O不成功
    6. **设备队列的队首指针**：指向等待该设备的<u>进程队列队首</u>
2. **控制器控制表（COCT）**

    一个设备控制器对应一张COCT，OS根据COCT信息管理控制器

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041601729.png)​
3. **通道控制表（CHCT）**

    一个通道为多个控制器服务

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041604079.png)​
4. **系统设备表（SDT）**

    <u>整个系统只有一张SDT</u>，记录已连接到系统的所有物理设备情况

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041604888.png)​

#### 设备分配时应考虑的因素

1. **设备的固有属性**

    1. **独占设备**

        分配给某进程后，直到进程完成或主动释放
    2. **共享设备**

        可以同时分配给多进程，需要合理调度访问先后
    3. **虚拟设备**

        可共享设备，可以同时分配给多个进程
2. **设备分配算法**

    1. **FCFS算法**，先请求先使用，后请求排队使用
    2. **最高优先级优先算法**，高优先级进程优先，相同按FCFS
3. **设备分配安全性**

    1. **安全分配方式**

        进程发出I/O请求就阻塞，直到请求完成唤醒

        即一个时间段一个进程只能使用一个设备

        此时CPU和I/O设备<u>串行工作，利用率低</u>
    2. **不安全分配方式**

        仅当请求设备被另一进程占用才阻塞，一个进程可同时操作多设备，但可能死锁

#### 设备分配的步骤

1. **分配设备**

    1. 由I/O请求中的**物理设备名**查找SDT，得到DCT
    2. 由DCT读出设备状态，忙则进程进入设备等待队列，不忙则按策略分配
2. **分配控制器**

    1. 设备分配后由DCT得到COCT，查询控制器状态
    2. 忙则进程进入控制器等待队列，不忙则按策略分配
3. **分配通道**

    1. 控制器分配后由COCT得到CHCT，查询通道状态
    2. 忙则进程进入通道等待队列，不忙则按策略分配

设备、控制器、通道均分配成功，设备分配才成功

---

以上方法使用物理设备名分配，不具有设备独立性，若改用**逻辑设备名**，将从SDT中找到**该类设备的DCT**，找到一个空闲设备即分配，若均忙，才挂到**该类设备等待队列**，只要一个可用便开始分配

#### 逻辑设备名到物理设备名的映射

**逻辑设备表（Logical Unit Table, LUT）** ，将逻辑设备名映射为物理设备名

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041640471.png)​

1. **整个系统LUT**

    适用于单用户系统，逻辑设备名用户不能相同
2. **每个用户LUT**

    不同用户可以使用相同逻辑设备名

**优点：**

1. 方便用户编程
2. 程序运行不熟具体机器环境限制
3. 便于程序移植

### SPOOLing技术（假脱机技术）

可以将独占设备改造为共享设备

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408042056876.png)​

1. **输入缓冲区和输出缓冲区**

    内存中的两个区域

    输入区用于暂存输入设备输入的数据，待时机传送到输入井

    输出区攒出输出井传出的数据，待时机传送到输出设备
2. **输入井和输出井**

    磁盘上的两个存储区域

    输入井保存输入缓冲区传来的I/O数据

    输出井保存准备要输出的数据

    输入输出数据都会被保存为文件，这些文件<u>被链接为两个队列</u>
3. **输入进程和输出进程**

    输入进程控制输入数据进入输入缓冲区再进入输入井

    输出进程控制输出数据进入输出缓冲区，待设备空闲再发送到输出设备
4. **井管理程序**

    控制作业和磁盘井之间信息交换

例子：打印机为独占设备，进程发出打印请求，系统在输出井中分配一缓冲区（相当于逻辑打印机），请求暂存于缓存区中，使得进程认为独占了打印机。打印机速度慢，CPU发送打印请求后必须等待完成才能继续其他，而使用SPOOLing则只需要快速将打印数据保存到磁盘中，待输出进程调度即可，CPU就不需要再等待了

* **SPOOLing特点**

  1. **提高I/O速度**

      低速设备执行与CPU的I/O操作变为从缓冲区中存取，缓和CPU和设备速度不匹配问题
  2. **独占设备改造为共享设备**

      例如打印机
  3. **实现虚拟设备功能**

      每个进程都认为自己独占了设备
  4. **提高独占设备利用率**
  5. **以空间换时间**

### 设备驱动程序接口

* **功能**

  1. 接收上层软件命令和参数，将抽象要求转化为对设备的具体要求
  2. 检查用户I/O请求的合法性，了解设备工作状态，传递设备操作有关参数，设置设备工作方式
  3. 发出I/O命令，空闲立刻完成，忙挂到设备等待队列
  4. 及时响应设备控制器中断请求并调用中断处理程序处理
* **特点**

  1. 请求转换并传送后，将设备控制器记录的设备状态和操作完成情况反馈给进程
  2. 驱动程序与设备I/O控制方式紧密相关，常用中断驱动方式和DMA方式
  3. 设备驱动程序与硬件紧密相关
  4. 设备驱动程序允许同时多次调用执行

## 磁盘和固态硬盘

### 磁盘（Disk）

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408050921546.png)​

* **磁盘**

  1. **磁盘**

      磁盘表面覆盖磁性物质，用以记录二进制数据
  2. **磁头**

      导体线圈，读取磁盘数据，读写期间磁头不动，磁盘高速旋转
  3. **磁道**

      磁盘表面划分的一组同心圆，磁道宽带和磁头一致，一个盘面有上千磁道
  4. **扇区**

      一个磁道划分几百扇区，扇区存储大小固定，1个扇区就是一个盘块

      原始磁盘中，扇区圆心角在各个磁道中固定，因此最内侧磁道划分的扇区密度决定了磁盘存储容量

      现代磁盘中不再如此设计，磁道由内向外被分成多个区域，每个<u>区域内的磁道有相同数量的扇区</u>，但<u>不同区域的磁道扇区数量不同</u>。外圈的磁道有更多的扇区，从而提高了磁盘的总体容量
  5. **柱面**

      所有盘面相对位置相同的磁道组成柱面
* **磁盘驱动器**

  由**磁头臂**、**转轴**和**数据输入输出电子设备**组成
* **磁盘分类**

  多个<u>盘面垂直堆叠组成磁盘组</u>，每个盘面对应一个磁头

  1. **活动头磁盘**：磁头可移动，磁头臂来回伸缩定位磁道
  2. **固定头磁盘**：磁头相对于盘片径向方向固定
  3. **固定盘磁盘**：盘片永久固定
  4. **可换盘磁盘**：盘片可以移动和替换
* **磁盘的物理地址**

  使用“**柱面号·盘面号·扇区号**”来定位任意一个磁盘块

  * **由物理地址读取**

    1. 根据**柱面号**移动磁头臂，磁头指向指定柱面
    2. 激活**指定盘面**的刺头
    3. 磁盘旋转时，**指定扇区**会从磁头下扫过，即完成读写

### 磁盘的管理

#### 格式化过程

1. **低级格式化（物理格式化）**

    磁盘存储数据前需要<u>划分扇区</u>，即**低级格式化（物理格式化）**

    扇区由头部、数据区域、尾部组成。头尾包含磁盘控制器的使用信息

    大多数磁盘工厂生产时已完成低级格式化
2. **分区**

    将磁盘分区（C盘D盘），每个分区由一个/多个柱面组成

    分区<u>起始扇区和大小</u>记录在<u>主引导记录分区表</u>
3. **物理分区逻辑格式化（高级格式化）**

    将初始文件系统数据（空闲空间、已分配空间、空目录）存储到磁盘中

    建立根目录、对保存空闲磁盘块信息的数据结构初始化

#### 引导块

计算机启动时运行初始化程序（自举程序），程序存放在ROM（BIOS）中

自举程序将引导块读入内存，并加载引导程序（Boot Loader）

引导块的主要作用是在计算机启动时加载并执行引导加载程序（Boot Loader），然后由引导加载程序进一步加载操作系统的核心部分（Kernel）

#### 坏块

磁盘容易导致一个或多个扇区损坏，称为坏块

<u>处理坏块实际上就是使用机制使得操作系统不使用坏块</u>

在低级格式化的时候，工厂可能会保留隐藏一些备用块，出现坏块时控制器采用备用块逻辑替换，称为**扇区备用**

### 磁盘调度算法

#### 磁盘存取时间

一次磁盘读写时间由寻道时间、旋转延迟时间和传输时间决定

1. **寻道时间Ts**

    磁头移动到目的磁道所需时间

    跨越n条磁道时间，磁头臂启动时间s

    $T_s=m\times n+s$  

    m为磁盘相关常数
2. **旋转延迟时间Tr**

    通过旋转磁盘，磁头定位到读写扇区所需时间

    磁盘一分钟圈数RPM

    $T_{\mathrm{r}}=\frac{60}{RPM}·\frac12$
3. **传输时间Tt**

    磁盘读写数据所需时间

    每次读写字节数b，磁盘一分钟圈数RPM，一个磁道字节数N

    $T_{\mathrm{r}}=\frac{60}{RPM}·\frac bN$
4. **总平均存取时间Ta**

    $T_a=T_s+T_R+T_t$  

    其中寻道时间占多，磁盘调度的主要目标是减少寻道时间

#### 磁盘调度算法

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408051053988.png)​

* **其他减少延迟时间的方法**

  磁头读入一个扇区后，需要经过处理才能继续读入下一个扇区

  因此如果一个进程的两个连续逻辑块，在磁盘中如果物理块相邻，在处理时第二物理块已经错过，则延迟时间将很大

  因此在盘面扇区中采用**交替编号**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408051058809.png)​

  不同盘面块连续读入时，在切换盘面也需要处理时间

  因此对不同盘面采用**错位命名**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408051100793.png)​
* **提高磁盘I/O速度的方法**

  1. **采用磁盘高速缓存**
  2. **调整磁盘请求顺序**

      磁盘调度算法
  3. **提前读**

      读当前块时，下一块也读入内存缓冲区
  4. **延迟写**
  5. **优化物理块分布**

      将同一个文件盘块安排在一个磁道或相邻磁道减少寻道时间，或按簇对文件进行分配

      簇：一组扇区
  6. **虚拟盘**

      内存空间模拟磁盘
  7. **采用磁盘阵列RAID**

### 固态硬盘

#### 固态硬盘特性

**固态硬盘（Solid State Disk, SSD）** ，由多个闪存芯片和闪存翻译层构成

闪存芯片——机械驱动器

闪存翻译层——磁盘控制器

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408051108566.png)​

* 闪存——块——页结构，数据<u>以页为单位读写</u>
* 擦除按块进行，<u>擦除后块中的页可以再写一次</u>
* 块<u>重复擦写后，会出现磨损</u>，无法再使用
* 随机写较慢，若写操作<u>修改页含有内容，需要将整个块移动到空闲块</u>

#### 均衡磨损

部分闪存损坏，整个SSD损坏，磨损不均衡会大幅缩短固态寿命

1. **动态磨损均衡**

    写入时<u>自动选择新块</u>
2. **静态磨损均衡**

    自动监测并进行数据分配，使得<u>老块无需写数据，新块进行读写操作</u>

‍

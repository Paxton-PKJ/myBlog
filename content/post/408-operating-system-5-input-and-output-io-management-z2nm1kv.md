---
title: 408操作系统—5.输入输出(IO)管理
slug: 408-operating-system-5-input-and-output-io-management-z2nm1kv
url: /post/408-operating-system-5-input-and-output-io-management-z2nm1kv.html
date: '2024-08-02 15:22:35+08:00'
lastmod: '2024-08-04 21:29:42+08:00'
toc: true
tags:
  - '408'
  - 操作系统
categories:
  - 提桶跑路笔记
keywords: 408,操作系统
isCJKLanguage: true
---





## I/O 管理概述

### I/O 设备

#### I/O 设备分类

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408012040707.png)​

#### I/O 接口（设备控制器）

CPU 与设备之间的接口

* **主要功能**

  * 接受和识别 CPU 发来的命令
  * 数据交换（设备和控制器的数据交换 + 控制器和主存数据交换）
  * 标识和报告设备的状态，以供 CPU 处理
  * 地址识别；数据缓冲；差错控制
  * <u>设备控制器不属于操作系统范畴，它是属于硬件</u>
* **组成**

  1. **设备控制器 &amp; CPU**

     * **数据线**

       传输读写数据、控制信息、状态信息
     * **地址线**

       传送要访问 I/O 接口中的寄存器编号
     * **控制线**

       发出读写控制信号

     CPU 通过<u>控制线发出命令</u>，通过<u>地址线指明要操作的设备</u>，通过<u>数据线来输入输出数据</u>
  2. **设备控制器 &amp; 设备**

     一对多，每个接口都可以传输<u>数据、控制和状态</u>三种类型信号，用于实现<u>控制器和设备之间通信</u>
  3. **I/O 逻辑**

     * 负责接受和识别 CPU 的命令
     * 根据命令对相应设备发送命令
     * 实现设备控制功能

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408012059865.png)​

#### I/O 接口类型

1. **按数据传输方式**

   * 并行接口：一个字节或一个字的所有位同时传送
   * 串行接口：一位一位传送
2. **按主机控制设备的方式**

   程序查询接口、中断接口、DMA 接口等
3. **按功能选择的灵活性**

   可编程接口、不可编程接口

#### I/O 端口

指设备控制器中<u>可被 CPU 直接访问的寄存器</u>

1. 分类

   * **数据寄存器**

     CPU 向 I/O 设备<u>写入需要传输的数据</u>
   * **状态寄存器**

     告知 CPU 已经在工作或工作已经完成

     <u>工作状态，CPU 再发送数据或者命令将无效</u>

     工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令
   * **控制寄存器**

     由 cpu 写入以改变设备运行模式或启动命令
2. **编址**

   1. **独立编址**

      每个端口分配一个端口号，端口地址空间和主存地址空间之间独立

      只有操作系统使用指令才能访问端口

      * **优点**

        专用指令程序清晰

        硬件实现简单，只需要少量地址线，寻址速度快
      * **缺点**

        指令少，<u>程序灵活性差</u>

        两组系统<u>增加控制复杂性</u>
   2. **统一编址**

      又称内存映射 I/O，主存地址提供一部分用于 I/O 端口

      * **优点**

        无需专用指令，访存指令即可，<u>程序简单</u>

        端口拥有较大编址空间，访存保护由虚拟存储管理系统实现
      * **缺点**

        主存可用容量变小

        硬件实现复杂，全部地址线参与译码

### I/O 控制方式

<u>控制设备和主机</u>之间的数据传送

发展宗旨：<u>减少 CPU 对 I/O 控制的干预</u>

#### 程序直接控制方式

CPU <u>循环从设备读取一个字节</u>，循环测试设备状态（轮询），直到字节已经在设备控制器的数据寄存器中，取出送入内存

<u>实现简单</u>，但 CPU 大部分时间都在等待完成，利用率低

CPU <u>未采用中断机构</u>，I/O 设备无法报告已完成，CPU 只能主动询问

#### 中断驱动方式

允许 I/O 设备主动打断 CPU 运行并请求服务，使得 CPU 向设备控制器发出一条 I/O 指令后继续其他工作

CPU 和设备并行工作，CPU 效率提升

设备和内存交换<u>数据必须经过 CPU 寄存器</u>，效率低

此方式<u>以字节为单位交换数据</u>，对于<u>块设备效率极低</u>

#### DMA 方式（直接存储器存取）

在 I/O 设备和内存之间开辟直接数据交换通路

* **特性**

  1. 基本传送单位为<u>数据块</u>
  2. 数据不再经过 CPU
  3. 只有<u>开始传送和传送结束时</u>需要 CPU 干预
* **寄存器**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240802134655-z18f8t8.png)​

  1. **命令/状态寄存器（CR）**

     接收从 CPU 发来的 I/O 命令、有关控制信息，设备的状态
  2. **内存地址寄存器（MAR）**

     存放将数据从设备传送到内存的<u>起始目标地址</u>
  3. **数据寄存器（DR）**

     暂存从设备到内存或从内存到设备的<u>数据</u>
  4. **数据计数器（DC）**

     存放本次要传送的<u>字节数</u>
* **工作流程**

  1. CPU 收到 DMA 请求，向 DMA 控制器发出启动命令，设置 MAR、DC 初值
  2. I/O 控制权交给 DMA，DMA 直接与内存交互，一次传送一个字节，CPU 不参与
  3. 传输结束，DMA 控制器发出中断信号给 CPU

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408021351598.png)​

#### 通道控制方式

I/O 通道是一种特殊的处理机，执行通道指令

* **特性**

  1. CPU、通道、I/O 设备并行工作，资源利用率高
  2. 实现复杂，需要<u>专门 I/O 通道处理器</u>
  3. 一个通道可以控制<u>多台设备与内存数据交换</u>
* **工作流程**

  1. CPU 向通道发出 I/O 指令，指明通道程序在内存位置和要访问的设备
  2. 通道程序执行，完成 I/O 任务后，发出中断请求
* **通道与一般处理机区别**

  指令单一，没有内存，<u>与 CPU 共享内存</u>
* **通道与 DMA 区别**

  通道传输的<u>数据块大小和传输的内存位置</u>由通道控制

  通道可以同时<u>控制多台设备</u>与内存的数据交换

#### 方式比较

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408021407539.png)​

### I/O 软件层次结构

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408021424982.png)​

1. **用户层软件**

   实现用户交互接口，必须通过系统调用获取服务

   如发送 read 命令
2. **设备独立性软件**

   * **设备独立性**

     也称设备无关性

     应用所用设备不局限于具体物理设备，从而引入逻辑设备和物理设备概念

     应用程序使用逻辑设备名进行请求，系统将逻辑设备名映射为物理设备名

     增加设备分配灵活性，易于实现 I/O 重定向
   * **软件功能**

     1. **执行所有设备的公有操作**

        设备分配回收、设备名映射、设备保护、缓冲管理、提供大小统一逻辑块、屏蔽设备交换单位和速率差异
     2. **向用户层提供统一接口指令**

        文件系统管理（如文件的创建、删除、读写等操作）
3. **设备驱动程序**

   * 提供与具体设备相关的 I/O 操作接口
   * 直接与硬件设备交互，处理设备特定的命令和状态，解析上层命令为指令
   * 实现设备初始化、配置和中断处理等功能
4. **中断处理程序**

   * 处理来自硬件设备的中断信号
   * 在中断发生时，保存当前的 CPU 状态，执行相应的中断服务例程
   * 通知设备驱动程序已完成相应的 I/O 操作
5. **硬件**

---

**各层次处理过程**

1. 用户需要<u>读取设备内容</u>，通过操作系统提供的 <u>read 命令接口</u>，经过**用户层**
2. 此时使用的通用接口，是每个设备都可以响应的统一命令，经过**设备独立层**进行<u>解析，然后交往下层</u>
3. 不同设备对 read 命令的行为有所不同。需要针对不同的设备，**设备驱动层**将 <u>read 命令解析成不同的指令</u>
4. 命令解析完毕后，需要<u>中断正在运行的进程，转而执行 read 命令</u>，这就需要**中断处理程序**
5. 命令真正抵达**硬件设备**，硬件设备的控制器<u>按照上层传达的命令操控硬件设备</u>，完成相应的功能

### 应用程序 I/O 接口

#### I/O 接口分类

1. **字符设备接口**

   * 用于访问字符设备，如键盘、鼠标、串口设备等
   * 数据按字符流的方式进行读写操作，设立**字符缓冲区**读写字符
   * 通常不支持随机访问，只能<u>顺序读写，传输速率低</u>
   * 输入输出通常采用<u>中断驱动</u>
   * 属于独占设备，提供打开、关闭操作实现<span data-type="text" id="">互斥共享</span>
2. **块设备接口**

   * 用于访问块设备，如<u>硬盘、光驱</u>等
   * 数据以<u>固定大小的块</u>进行读写操作
   * 支持随机访问，可以直接读取或写入特定的块，速度高，可寻址
   * 将上层传来的逻辑抽象命令转化为设备能识别的低层具体操作
   * 磁盘设备 I/O 常用 <span data-type="text" id="">DMA方式</span>
3. **网络设备接口**

   * 用于网络通信，支持数据包的发送和接收
   * 提供连接管理、数据传输、错误处理等功能
   * 支持多种网络协议，如 TCP、UDP 等
   * 网络套接字接口如 socket

#### 阻塞和非阻塞 I/O

- **阻塞 I/O**

  * **工作原理**

    1. 应用程序调用 I/O 函数（如 read、recv）
    2. 如果数据不可用，调用会阻塞，应用程序进入等待状态
    3. 一旦数据可用，I/O 操作完成，函数返回，应用程序继续执行
  * **优点**

    * <u>编程简单</u>，逻辑清晰
    * 适用于<u>不需要高并发处理</u>的场景
  * **缺点**

    * 当等待 I/O 操作完成时，<u>CPU 资源会被浪费</u>
    * <u>不适用于高并发场景</u>，可能导致性能瓶颈

* **非阻塞 I/O**

  * **工作原理**

    1. 应用程序调用非阻塞 I/O 函数（如 read、recv）并立即返回
    2. 如果数据不可用，函数<u>返回一个错误或特殊值</u>，表示数据未准备好
    3. 应用程序可以使用<u>轮询或事件通知机制</u>来检查数据是否可用
  * **优点**

    * 可以提高系统的并发处理能力和 <u>CPU 利用率</u>
    * 适用于<u>需要高并发处理</u>的场景，如网络服务器、实时系统等
  * **缺点**

    * <u>编程复杂度较高</u>，需要处理数据不可用的情况
    * 可能需要使用轮询或事件通知机制，<u>增加了编程难度，轮询将占用 CPU 时间</u>

## 设备独立性软件

### 设备独立性软件

### 高速缓存与缓冲区

#### 磁盘高速缓存（Disk Cache）

用于<u>提高磁盘I/O速度</u>，利用内存空间暂存磁盘中盘块信息

<u>逻辑上属于磁盘，物理上属于内存</u>

1. 内存单独使用<u>固定大小</u>空间作为缓存区
2. <u>未利用的全部内存</u>作为缓冲池

#### 缓冲区（Buffer）

* **引入目的**

  1. 缓和CPU与I/O设备间<u>速度不匹配</u>的矛盾
  2. 减少对CPU的<u>中断频率</u>，放宽对CPU中断响应时间的限制
  3. 解决基本<u>数据单元大小</u>（数据粒度）不匹配的问题
  4. 提高CPU和I/O设备之间的<u>并行性</u>
* **实现方法**

  1. 硬件缓冲器，成本高非必要不采用
  2. **内存缓冲区**

#### 缓冲技术分类

* **T时间**：磁盘——>缓冲区
* **M时间**：缓冲区——>用户
* **C时间**：CPU处理一块数据的时间

##### 单缓冲

通常为一个块

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240804105333-q4oxk1t.png)​

‍

<u>T、C可以并行进行</u>  

缓冲区为共享资源，互斥，要么输入要么读取，因此缓冲区冲满才能从缓冲区读取，<u>即M时间结束后才能进行下一个T时间</u>

1. **T &gt; C**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041056096.png)​
2. **T &lt; C**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041056936.png)​

<u>处理一块数据的时间为</u>​<u>$\max(C,T)+M$</u>

##### 双缓冲

先输入缓冲1，再输入缓冲2，CPU处理完1之后若2满接着处理2

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041103810.png)​

此时CMT并行

* **T &gt; C+M**

  即 传输时间和处理时间 快于 输入时间

  以至于<u>处理完一个块时下一个还没好，即下图M+C时刻</u>

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041108616.png)​
* **T &lt; C+M**

  当2T < 2M+C时，传输M和处理C不间断，即图示

  T时刻下一块准备好了，M+C时刻才处理完本块

  即<u>处理完一个块时，下一个块已经等着处理了</u>

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041110683.png)​

因此，平均时间为$\max(C+M,T)$

T和M+C速度基本匹配时效果最佳

##### 循环缓冲

多个大小相同缓冲区组成循环缓冲区，橙色满绿色空

<u>需要存入缓冲区，向in指针指向的冲入，移动in到下一个空缓冲区</u>

<u>需要取出缓冲区，从out指针指向的读取，移动out到下一个满缓冲区</u>

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041129430.png)​

##### 缓冲池

数据结构和操作函数组成的管理机制，用于管理多个缓冲区，多个进程共享使用

* **缓冲区按使用状况分为**

  1. 空缓冲队列：空缓冲区链接
  2. 输入队列：装满输入数据缓冲区链接
  3. 输出队列：装满输出数据缓冲区链接
* **缓冲池按功能分为**

  1. **收容输入**数据（hin）
  2. **提取输入**数据（sin）
  3. **收容输出**数据（hout）
  4. **提取输出**数据（sout）

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041159799.png)​

#### 高速缓存与缓冲区对比

|||高速缓存|缓冲区|
| -----------------------------------| :--------------------: | :-----------------------------------------------------------------------------------------| :-------------------------------------------------------------------------------|
|相同点||都介于高速设备和低速设备之间||
|区别|存放数据|低速设备上某些数据的复制数据<br /><br />即高速缓存上有的，低速设备上面必然有<br />|低速设备传递给高速设备的数据（或相反）<br /><br />不一定有备份<br />|
||目的|存放高速设备经常访问的数据<br /><br />若数据不在高速缓存中，则高速设备就需要从低速设备取得数据<br />|高速设备和低速设备的通信都要经过缓冲区<br /><br />高速设备永远不会直接去访问低速设备<br />|

### 设备分配与回收

根据用户的I/O请求分配所需设备，原则上要充分发挥设备，尽可能忙碌，避免死锁

#### 设备分配的数据结构

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041603302.png)​

1. **设备控制表（DCT）**

    <u>一个设备对应一个DCT</u>，表项为<u>设备属性</u>

    1. **设备类型**
    2. **设备标识符**：物理设备名
    3. **设备状态**：忙/闲，空闲即“设备回收”
    4. **指向控制器表的指针**
    5. **重复执行次数/时间**：达到该限制则I/O不成功
    6. **设备队列的队首指针**：指向等待该设备的<u>进程队列队首</u>
2. **控制器控制表（COCT）**

    一个设备控制器对应一张COCT，OS根据COCT信息管理控制器

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041601729.png)​
3. **通道控制表（CHCT）**

    一个通道为多个控制器服务

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041604079.png)​
4. **系统设备表（SDT）**

    <u>整个系统只有一张SDT</u>，记录已连接到系统的所有物理设备情况

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041604888.png)​

#### 设备分配时应考虑的因素

1. **设备的固有属性**

    1. **独占设备**

        分配给某进程后，直到进程完成或主动释放
    2. **共享设备**

        可以同时分配给多进程，需要合理调度访问先后
    3. **虚拟设备**

        可共享设备，可以同时分配给多个进程
2. **设备分配算法**

    1. **FCFS算法**，先请求先使用，后请求排队使用
    2. **最高优先级优先算法**，高优先级进程优先，相同按FCFS
3. **设备分配安全性**

    1. **安全分配方式**

        进程发出I/O请求就阻塞，直到请求完成唤醒

        即一个时间段一个进程只能使用一个设备

        此时CPU和I/O设备<u>串行工作，利用率低</u>
    2. **不安全分配方式**

        仅当请求设备被另一进程占用才阻塞，一个进程可同时操作多设备，但可能死锁

#### 设备分配的步骤

1. **分配设备**

    1. 由I/O请求中的**物理设备名**查找SDT，得到DCT
    2. 由DCT读出设备状态，忙则进程进入设备等待队列，不忙则按策略分配
2. **分配控制器**

    1. 设备分配后由DCT得到COCT，查询控制器状态
    2. 忙则进程进入控制器等待队列，不忙则按策略分配
3. **分配通道**

    1. 控制器分配后由COCT得到CHCT，查询通道状态
    2. 忙则进程进入通道等待队列，不忙则按策略分配

设备、控制器、通道均分配成功，设备分配才成功

---

以上方法使用物理设备名分配，不具有设备独立性，若改用**逻辑设备名**，将从SDT中找到**该类设备的DCT**，找到一个空闲设备即分配，若均忙，才挂到**该类设备等待队列**，只要一个可用便开始分配

#### 逻辑设备名到物理设备名的映射

**逻辑设备表（Logical Unit Table, LUT）** ，将逻辑设备名映射为物理设备名

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408041640471.png)​

1. **整个系统LUT**

    适用于单用户系统，逻辑设备名用户不能相同
2. **每个用户LUT**

    不同用户可以使用相同逻辑设备名

**优点：**

1. 方便用户编程
2. 程序运行不熟具体机器环境限制
3. 便于程序移植

### SPOOLing技术（假脱机技术）

可以将独占设备改造为共享设备

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408042056876.png)​

1. **输入缓冲区和输出缓冲区**

    内存中的两个区域

    输入区用于暂存输入设备输入的数据，待时机传送到输入井

    输出区攒出输出井传出的数据，待时机传送到输出设备
2. **输入井和输出井**

    磁盘上的两个存储区域

    输入井保存输入缓冲区传来的I/O数据

    输出井保存准备要输出的数据

    输入输出数据都会被保存为文件，这些文件<u>被链接为两个队列</u>
3. **输入进程和输出进程**

    输入进程控制输入数据进入输入缓冲区再进入输入井

    输出进程控制输出数据进入输出缓冲区，待设备空闲再发送到输出设备
4. **井管理程序**

    控制作业和磁盘井之间信息交换

例子：打印机为独占设备，进程发出打印请求，系统在输出井中分配一缓冲区（相当于逻辑打印机），请求暂存于缓存区中，使得进程认为独占了打印机。打印机速度慢，CPU发送打印请求后必须等待完成才能继续其他，而使用SPOOLing则只需要快速将打印数据保存到磁盘中，待输出进程调度即可，CPU就不需要再等待了

* **SPOOLing特点**

  1. **提高I/O速度**

      低速设备执行与CPU的I/O操作变为从缓冲区中存取，缓和CPU和设备速度不匹配问题
  2. **独占设备改造为共享设备**

      例如打印机
  3. **实现虚拟设备功能**

      每个进程都认为自己独占了设备
  4. **提高独占设备利用率**
  5. **以空间换时间**

### 设备驱动程序接口

* **功能**

  1. 接收上层软件命令和参数，将抽象要求转化为对设备的具体要求
  2. 检查用户I/O请求的合法性，了解设备工作状态，传递设备操作有关参数，设置设备工作方式
  3. 发出I/O命令，空闲立刻完成，忙挂到设备等待队列
  4. 及时响应设备控制器中断请求并调用中断处理程序处理
* **特点**

  1. 请求转换并传送后，将设备控制器记录的设备状态和操作完成情况反馈给进程
  2. 驱动程序与设备I/O控制方式紧密相关，常用中断驱动方式和DMA方式
  3. 设备驱动程序与硬件紧密相关
  4. 设备驱动程序允许同时多次调用执行

## 磁盘和固态硬盘

‍

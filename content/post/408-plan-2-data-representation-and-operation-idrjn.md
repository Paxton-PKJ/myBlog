---
title: 408计组——2.数据的表示和运算
slug: 408-plan-2-data-representation-and-operation-idrjn
url: /post/408-plan-2-data-representation-and-operation-idrjn.html
date: '2024-08-08 17:42:18+08:00'
lastmod: '2024-08-16 21:05:34+08:00'
toc: true
tags:
  - '408'
  - 计算机组成原理
categories:
  - 提桶跑路笔记
keywords: 408,计算机组成原理
isCJKLanguage: true
---





## 数制与编码

### 进位计数制及其相互转换

* **计算机采用二进制的原因**

  1. 二进制编码、运算规则简单，逻辑门电路能实现算术运算
  2. 使用两个稳定状态的物理器件即可以表示二进制
  3. 真假与 10 对应，为逻辑判断提供便利

#### 进位计数法

* **基数**

  每个数位用到的不同数码个数，十进制基数 10（0~9 数码）
* **位权**

  进位数每个<u>数位所占真实数值的权重</u>

  进位数数值大小即为<u>各位数码按权相加</u>
* **r 进制数**

  $K_nK_{n-1}...K_0K_{-1}...K_{-m}$

  r 进制数的 10 进制数值表示为：

  $K_nr^n+K_{n-1}r^{n-1}+\cdots+K_0r^0+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_ir^i$

  其中 r 为基数，r<sup>i</sup> 为第 i 位的位权，K<sub>i</sub> 为任意数码

  即**<u>数位的数字 x 该位位权 求和</u>**

---

1. **十进制（D，Decimal system）**
2. **二进制（B，Binary）**

   基数为 2，数位位权为 2<sup>i</sup>，i 为位数
3. **八进制（O，Octal number system）**

   基数为 8，3 位 2 进制数码为 1 组即 1 位 8 进制数码
4. **十六进制（H，Hexadecimal）**

   基数 16，数码 0~9+A~F，4 位 2 进制数码为 1 组即 1 位 16 进制数码

#### 进制转换

1. **B 转 O、B 转 H**

   (1 111 000 010.011 01)<sub>2</sub>

   ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240809110840-tyhd0xz.png)​

   以小数点分界，8 进制 3 位 1 组，<span data-type="text" id="">按权相加后结果</span>即 1 位 8 进制数

   二进制 `010`​ 转换为八进制： $0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 4 + 0 + 1 = 2$

   其他位同理，十六进制按 4 位一组同理
2. **任意进制转十进制**

   即 <span data-type="text" id="">r进制数</span>的十进制表示
3. **十进制转任意进制**

   * 整数部分**除基取余法**

     先取得的余数为最低位，商为 0 时结束

     ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092042725.png)​
   * 小数部分**乘积取整法**

     取小数部分乘进制，取整数，先取得为高位，直到乘积为 1.0

     ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092042733.png)​

     应注意并非所有十进制小数都可以准确使用二进制表示如 0.3

     任意二进制小数都能使用十进制表示

### 无符号数

机器字长全部二进制位<u>均为数值位，没有符号位</u>

n 位二进制数表示范围：0~2<sup>n</sup>-1

即 unsigned int，没有无符号小数

### 有符号数

#### 真值和机器数

* **真值**：+5，-5
* **机器数**：05,15

  通常使用 0 表示正，1 表示负，将<u>符号数字化</u>的数称为**机器数**

#### 原码

* **定点整数**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092115172.png)​
* **定点小数**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092116111.png)​

设<u>字长为 n+1</u>，定点数表示时不足位补 0

原码整数表示范围 $-(2^n-1)\leq x\leq2^n-1$，即 $2^{n+1}-1$ 个数

原码小数表示范围 $-(1-2^{-n})\leq x\leq1-2^{-n}$

<u>0 有两个表示形式 +0 和-0</u>

* **优点**

  1. 与真值对应关系简单直观
  2. 原码乘除运算简便
* **缺点**

  1. 0 的表示不唯一
  2. 加减运算复杂

#### 反码

符号位为 0，与原码一致

符号位为 1，数值位取反

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092138508.png)​

表示范围与原码一致，**反码为原码转补码的中间态，无实际作用**

#### 补码

正数补码 = 原码

负数原码 转 补码——数值位取反 +1

负数补码 转 原码——数值位取反 +1

补码取相反数——全部取反 +1

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092145087.png)​

$\begin{aligned}&[+0]_\text{原}{=00000000}&&[-0]_\text{原}{=10000000}\\&[+0]_\text{反}{=00000000}&&[-0]_\text{反}{=11111111}\end{aligned}$

**补码真值 0 只有一个表示[+0]**​<sub>**补**</sub>​ **=[-0]**​<sub>**补**</sub>​ **=00000000**

此时补码将多余一个二进制表示，规定

* **定点整数**

  补码<u>{x}</u>​<sub><u>补</u></sub>​<u>=1,0000000 表示真值-2</u>​<sup><u>7</u></sup>

  表示范围 $-(2^{n})\leq x\leq2^{n}-1$
* **定点小数**

  补码<u>{x}</u>​<sub><u>补</u></sub>​<u>=1.0000000 表示真值-1</u>

  表示范围 $-1\leq x\leq1-2^{-n}$

---

* **补码表示有符号整数优势**

  1. 0的补码表示唯一
  2. 补码运算规则简单，符号位参与二进制计算
  3. 多表示一个最小负数

#### 移码

将<u>补码符号位取反</u>，**只能表示整数**

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092203761.png)​

* 移码保持了数据原有的大小顺序，真值大移码大
* 移码只有一个零表示
* 和补码一样多表示一个最小负数

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240810151601-7y5q9da.png)​

#### 相互转换

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101544258.png)​

### C语言中整数类型及类型转换

#### C语言整型数据类型

* **字符型**

  ​`char`​，8位
* **短整型**

  ​`short`​、`short int`​，16位
* **整型**

  ​`int`​，32位
* **长整型**

  ​`long`​、`long int`​，由机器位数决定

---

​`char`​默认为**有符号整数**，其他默认<u>无符号整数</u>（`unsigned`​）

整型数据按补码形式存储，<u>​`unsigned`​</u>​<u>最高位为</u>​<u>**数值位**</u>​<u>，</u>​<u>​`signed`​</u>​<u>为</u>​<u>**符号位**</u>

#### 有符号数无符号数转换

强制类型转换的结果——<u>位值不变，改变解释位的方式</u>

* ​`short`​转`unsigned short`​

  ```c
  short x=-4321;
  unsigned short y=(unsigned short)x;//y=61215
  ```

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101616258.png)​

  第15位由<u>符号位变为数值位</u>

同时存在无符号数与有符号数参与运算时，<u>规定按无符号数计算</u>

#### 不同字长整数转换

* **大字长转小字长**

  多余高位直接舍去，低位直接赋值
* **小字长转大字长**

  低位位值保持小字长不变，高位位值填充：

  * 原数字**无符号整数：** 高位位值填充0
  * 原数字**有符号整数：高位位值填充原数字符号位**

    ```c
    short x = -4321
    int y = x
    //x=y=-4321
    x的补码为1110 1111 0001 1111
    y的补码为1111 1111 1111 1111 1110 1111 0001 1111
    y高位填充符号位
    ```

    ```c
    short x = -4321
    unsigned short u = (unsigned short)x
    //x=-4321 u=61215
    x的补码为1110 1111 0001 1111
    u的补码为1110 1111 0001 1111
    x的最高位由符号位变为数值位，真值变大
    ```

    ```c
    unsigned short u = 61215
    unsigned int v = u
    //x=61215 u=61215
    x的补码为1110 1111 0001 1111
    u的补码为0000 0000 0000 0000 1110 1111 0001 1111
    无符号进行零扩展，填充0
    ```

## 运算电路

### 数电基础

#### 逻辑门电路

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101716833.png)​

#### 多路选择器（MUX，multiplexer）

多输入中选择一个输入通过MUX

使用**控制信号op**控制输入，<u>k个输入的控制信号位数</u>为$\mathrm{m}\geq[\log_{2}k] bit$  

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132000597.png)​

当预留一个信号用于阻止所有输入时，$\mathrm{m}\geq[\log_{2}k+1] bit$  

#### 三态门

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132002423.png)​

控制单线数据是否能够通过

### 基本运算部件

#### 加法器

##### 一位全加器（FA）

最基本加法单元，支持<u>1位的加法运算</u>

* 实现

  1. **本位和**：$\mathrm{S_i}=\mathrm{A_i}\oplus\mathrm{B_i}\oplus\mathrm{C_i}$
  2. **高位进位**：$C_i=A_i B_i+(A_i\oplus B_i) C_{i-1}$

##### 并行加法器

* **串行进位**

  n个FA相连得到n位加法器，支持<u>n位并行加</u>

  进位信息串行产生，<u>速度慢</u>
* **并行进位**

  在串行进位基础上优化增加**CLA（超前进位部件）**

  进位信息并行产生，<u>速度快，相互进位没有依赖关系</u>

##### 带标志位加法器

能够进行有符号整数加减运算

* **OF（Over Flag）溢出标志**

  判断<u>带符号数运算</u>是否溢出，1溢出

  $OF=C_{n}\oplus C_{n-1}$
* **SF（Sign FLag）符号标志**

  判断运算结果正负性，1为负

  $SF$=<u>补码运算结果最高位</u>
* **ZF（Zero Flag）零标志**

  判断结果是否为零,1为零

  $ZF=\overline{S_{n}+\cdots+S_{2}+S_{1}}$
* **CF（Carry Flag）进位/借位标志**

  判断<u>无符号数运算</u>是否溢出，1溢出

  $CF=C_{\mathrm{out}}^{}\oplus C_{\mathrm{in}}^{}=C_{\mathrm{n}}^{}\oplus C_0$

#### 算术逻辑单元（ALU）

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132007671.png)​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132019744.png)​

* CPU的核心是ALU，<u>ALU的核心是</u>​<u>**加法器**</u>
* ALUop发出控制信号决定ALU的处理操作，<u>支持k种功能</u>，则控制信号位数$\mathrm{m}\geq[\log_{2}k] bit$
* 发出控制信号后，由一个MUX选择输出某种操作结果
* <u>ALU的运算位数决定了计算机的</u>机器字长
* 标志位表示运算结果特征，送入**PSW程序状态字寄存器**中保存（**FR标志寄存器**）

## 定点数的表示和运算

### 定点数的移位运算

#### 算术移位

* **原码的算术移位**

  <u>符号位不变，数值位整体移动</u>

  * **右移**

    <u>高位补0，低位舍弃</u>

    <u>**舍弃0**</u>​<u>，相当于÷2</u>；<u>**舍弃1**</u>​<u>，则丢失精度</u>

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240815193514-3bkxixp.png)​

    即图中最右侧1移位后其位权为2<sup>-1</sup>，被舍弃，丢失1/2
  * **左移**

    <u>低位补0，高位舍弃</u>

    **<u>舍弃0</u>**​<u>，相当于x2；</u>​**<u>舍弃1</u>**​<u>，产生严重误差</u>

    和右移同理，高位舍弃1的位权过大，故误差严重
* **反码算术移位**

  * **正数**与原码相同
  * **负数**补位使用1，其他相同
* 补码**算术移位**

  * **正数**与原码相同
  * **负数**

    * **右移**（同反码）：<u>高位补1，低位舍弃</u>
    * **左移**（同原码）：<u>低位补0，低位舍弃</u>

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408151953587.png)​

||码|添补|
| :-------------------------------: | :-------------------------------: | :-----: |
|正数|原、补、反|0|
|负数|原码|0|
||补码|左移0|
|||右移1|
||反码|1|

#### 逻辑移位

视为<u>无符号数移位</u>

左移，低位补0

右移，高位补0

#### 循环移位

* **不带进位位**

  首尾相接移位
* **带进位位**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408152019835.png)​

### 定点数加减运算

#### 原码加减

**同号加法**，取绝对值相加，保持符号不变

**异号加法**，取绝对值大者-小者，符号同大者

减法运算将<u>“减数”取反转为加法</u>

#### 补码加减

直接将符号位和数值位一起按二进制规则运算

溢出高位舍弃

补码减法转变为加法进行运算

#### 补码加法**溢出**

* **上溢**

  结果超过+127

  正+正=负
* **下溢**

  结果小于-128

  负+负=正

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408161525625.png)​

如三位补码，当计算2+2时，010+010=100（2+2=-4），即从2开始沿数轴移动两格得到-4

* **溢出判断**

  1. **一位符号法**

      依据正+正=负以及负+负=正判断

      $V=A_{\mathrm{S}}B_{\mathrm{S}}\overline{S_{\mathrm{S}}}+\overline{A_{\mathrm{S}}}\overline{B_{\mathrm{S}}}S_{\mathrm{S}}$  

      V=0，无溢出

      V=1，溢出
  2. **一位符号由数据位进位情况判断**

      分别记录符号位进位、最高数值位进位，异或判断

      上溢：0、1

      下溢：1、0
  3. **双符号位法（模4补码）**

      正数为00，负数为11

      当两位数不同时发生溢出，<u>异或判断</u>

      此时第一位表示正确的正负性，第二位表示错误得到的正负性

      上溢：01

      下溢：10

      双符号位只有在计算时复制一位符号，存储时不会增加占用

## 无符号数补码的加减运算

加法直接相加，溢出舍弃

<u>减法需要转换为加法</u>计算，<u>**将“减数”的全部位取反+1**</u>

> 转换原理：
>
> 计算机中8位二进制数，其表示范围为0~255
>
> 两个8位二进制数相加，<u>超过8位的部分将被硬件舍弃</u>，也即**对原结果进行了%2**​<sup>**8**</sup>
>
>   1011 1100 (188)<sub>10</sub> +
>
>   0100 0110 (70)<sub>10</sub> =
>
> 1 0000 0010 (258)<sub>10</sub> 舍去首位1
>
>   <u>0000 0010 (2)</u>​<sub><u>10</u></sub>   即结果为2，258 % 256 = 2
>
> 合理利用溢出舍去的特性，可以将减法变为加法
>
> 十进制下，188 - **80** = 108 在模2<sup>8</sup>意义下转变为加法即 ( 188 + **176** )% 256 = 108
>
> 利用硬件的自然溢出即可将减法转变为加法
>
> 1011 1100 -        1011 1100 +
>
> **0101 0000** =        **1011 0000** =
>
> 0110 1100        1 <u>0110 1100</u>
>
> **80** + **176** = 256 转变方法即<u>**将“减数”的全部位取反+1**</u>
>
> 0101 0000 取反
>
> 1010 1111 +1
>
> **1011 0000**

* **溢出判断**

  * **加法**

    产生进位1，溢出
  * **减法**

    转为加法时，产生进位0，溢出

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240816204123-xen7jd2.png)​

‍

## 浮点数的表示和运算

‍

---
title: 408计组——2.数据的表示和运算
slug: 408-plan-2-data-representation-and-operation-idrjn
url: /post/408-plan-2-data-representation-and-operation-idrjn.html
date: '2024-08-08 17:42:18+08:00'
lastmod: '2024-08-24 14:23:30+08:00'
toc: true
tags:
  - '408'
  - 计算机组成原理
categories:
  - 提桶跑路笔记
keywords: 408,计算机组成原理
isCJKLanguage: true
---





## 数制与编码

### 进位计数制及其相互转换

* **计算机采用二进制的原因**

  1. 二进制编码、运算规则简单，逻辑门电路能实现算术运算
  2. 使用两个稳定状态的物理器件即可以表示二进制
  3. 真假与 10 对应，为逻辑判断提供便利

#### 进位计数法

* **基数**

  每个数位用到的不同数码个数，十进制基数 10（0~9 数码）
* **位权**

  进位数每个<u>数位所占真实数值的权重</u>

  进位数数值大小即为<u>各位数码按权相加</u>
* **r 进制数**

  $K_nK_{n-1}...K_0K_{-1}...K_{-m}$

  r 进制数的 10 进制数值表示为：

  $K_nr^n+K_{n-1}r^{n-1}+\cdots+K_0r^0+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_ir^i$

  其中 r 为基数，r<sup>i</sup> 为第 i 位的位权，K<sub>i</sub> 为任意数码

  即**<u>数位的数字 x 该位位权 求和</u>**

---

1. **十进制（D，Decimal system）**
2. **二进制（B，Binary）**

   基数为 2，数位位权为 2<sup>i</sup>，i 为位数
3. **八进制（O，Octal number system）**

   基数为 8，3 位 2 进制数码为 1 组即 1 位 8 进制数码
4. **十六进制（H，Hexadecimal）**

   基数 16，数码 0~9+A~F，4 位 2 进制数码为 1 组即 1 位 16 进制数码

#### 进制转换

1. **B 转 O、B 转 H**

   (1 111 000 010.011 01)<sub>2</sub>

   ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240809110840-tyhd0xz.png)​

   以小数点分界，8 进制 3 位 1 组，<span data-type="text" id="">按权相加后结果</span>即 1 位 8 进制数

   二进制 `010`​ 转换为八进制： $0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 4 + 0 + 1 = 2$

   其他位同理，十六进制按 4 位一组同理
2. **任意进制转十进制**

   即 <span data-type="text" id="">r进制数</span>的十进制表示
3. **十进制转任意进制**

   * 整数部分**除基取余法**

     先取得的余数为最低位，商为 0 时结束

     ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092042725.png)​
   * 小数部分**乘积取整法**

     取小数部分乘进制，取整数，先取得为高位，直到乘积为 1.0

     ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092042733.png)​

     应注意并非所有十进制小数都可以准确使用二进制表示如 0.3

     任意二进制小数都能使用十进制表示

### 无符号数

机器字长全部二进制位<u>均为数值位，没有符号位</u>

n 位二进制数表示范围：0~2<sup>n</sup>-1

即 unsigned int，没有无符号小数

### 有符号数

#### 真值和机器数

* **真值**：+5，-5
* **机器数**：05,15

  通常使用 0 表示正，1 表示负，将<u>符号数字化</u>的数称为**机器数**

#### 原码

* **定点整数**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092115172.png)​
* **定点小数**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092116111.png)​

设<u>字长为 n+1</u>，定点数表示时不足位补 0

原码整数表示范围 $-(2^n-1)\leq x\leq2^n-1$，即 $2^{n+1}-1$ 个数

原码小数表示范围 $-(1-2^{-n})\leq x\leq1-2^{-n}$

<u>0 有两个表示形式 +0 和-0</u>

* **优点**

  1. 与真值对应关系简单直观
  2. 原码乘除运算简便
* **缺点**

  1. 0 的表示不唯一
  2. 加减运算复杂

#### 反码

符号位为 0，与原码一致

符号位为 1，数值位取反

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092138508.png)​

表示范围与原码一致，**反码为原码转补码的中间态，无实际作用**

#### 补码

正数补码 = 原码

负数原码 转 补码——数值位取反 +1

负数补码 转 原码——数值位取反 +1

补码取相反数——全部取反 +1

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092145087.png)​

$\begin{aligned}&[+0]_\text{原}{=00000000}&&[-0]_\text{原}{=10000000}\\&[+0]_\text{反}{=00000000}&&[-0]_\text{反}{=11111111}\end{aligned}$

**补码真值 0 只有一个表示[+0]**​<sub>**补**</sub>​ **=[-0]**​<sub>**补**</sub>​ **=00000000**

此时补码将多余一个二进制表示，规定

* **定点整数**

  补码<u>{x}</u>​<sub><u>补</u></sub>​<u>=1,0000000 表示真值-2</u>​<sup><u>7</u></sup>

  表示范围 $-(2^{n})\leq x\leq2^{n}-1$
* **定点小数**

  补码<u>{x}</u>​<sub><u>补</u></sub>​<u>=1.0000000 表示真值-1</u>

  表示范围 $-1\leq x\leq1-2^{-n}$

---

* **补码表示有符号整数优势**

  1. 0 的补码表示唯一
  2. 补码运算规则简单，符号位参与二进制计算
  3. 多表示一个最小负数

#### 移码

**只能表示整数**

<u>移码=真值 + 偏置值</u>，本例中偏置值取 2<sup>n-1</sup>，在 <u>IEEE754 标准中取 2</u>​<sup><u>n-1</u></sup>​<u>-1</u>

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408092203761.png)​

* 移码保持了数据原有的大小顺序，<u>真值大移码大</u>
* 移码<u>只有一个零表示</u>
* 和补码一样多表示一个最小负数

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240810151601-7y5q9da.png)​

#### 相互转换

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101544258.png)​

### C 语言中整数类型及类型转换

#### C 语言整型数据类型

* **字符型**

  ​`char`​，8 位
* **短整型**

  ​`short`​、`short int`​，16 位
* **整型**

  ​`int`​，32 位
* **长整型**

  ​`long`​、`long int`​，由机器位数决定

---

​`char` ​默认为**有符号整数**，其他默认<u>无符号整数</u>（`unsigned`​）

整型数据按补码形式存储，<u>​`unsigned`​</u> <u>最高位为</u>​<u>**数值位**</u>​<u>，</u>​<u>​`signed`​</u> <u>为</u>​<u>**符号位**</u>

#### 有符号数无符号数转换

强制类型转换的结果——<u>位值不变，改变解释位的方式</u>

* ​`short` ​转 `unsigned short`​

  ```c
  short x=-4321;
  unsigned short y=(unsigned short)x;//y=61215
  ```

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101616258.png)​

  第 15 位由<u>符号位变为数值位</u>

同时存在无符号数与有符号数参与运算时，<u>规定按无符号数计算</u>

#### 不同字长整数转换

* **大字长转小字长**

  多余高位直接舍去，低位直接赋值
* **小字长转大字长**

  低位位值保持小字长不变，高位位值填充：

  * 原数字**无符号整数：** 高位位值填充 0
  * 原数字**有符号整数：高位位值填充原数字符号位**

    ```c
    short x = -4321
    int y = x
    //x=y=-4321
    x的补码为                    1110 1111 0001 1111
    y的补码为1111 1111 1111 1111 1110 1111 0001 1111
    y高位填充符号位
    ```

    ```c
    short x = -4321
    unsigned short u = (unsigned short)x
    //x=-4321 u=61215
    x的补码为1110 1111 0001 1111
    u的补码为1110 1111 0001 1111
    x的最高位由符号位变为数值位，真值变大
    ```

    ```c
    unsigned short u = 61215
    unsigned int v = u
    //x=61215 u=61215
    x的补码为                    1110 1111 0001 1111
    u的补码为0000 0000 0000 0000 1110 1111 0001 1111
    无符号进行零扩展，填充0
    ```

### 数据的存储和排列

#### 大小端方式存储

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211332020.png)​

#### 对齐方式存储

计算机按字节编址，一个字节对应一个地址

* **边界对齐**

  浪费部分空间，读取速度快

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211346850.png)​
* **边界不对齐**

  空间利用率高，读取速度慢

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211346870.png)​

#### 存储单位

* **字节（B，Byte）**

  **数据处理**的基本单位

  **一个字节由 8 个二进制位构成**，即 1 个字节等于 8 个比特（1 Byte \= 8 bit）
* **比特（b，bit）**

  计算机内部**数据存储**的最小单位

  每个比特都由“0”和“1”表示

  11010100 是一个 8 位二进制数，其中每一位都是一个比特

## 运算电路

### 数电基础

#### 逻辑门电路

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408101716833.png)​

#### 多路选择器（MUX，multiplexer）

多输入中选择一个输入通过 MUX

使用**控制信号 op** 控制输入，<u>k 个输入的控制信号位数</u>为 $\mathrm{m}\geq[\log_{2}k] bit$

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132000597.png)​

当预留一个信号用于阻止所有输入时，$\mathrm{m}\geq[\log_{2}k+1] bit$

#### 三态门

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132002423.png)​

控制单线数据是否能够通过

### 基本运算部件

#### 加法器

##### 一位全加器（FA）

最基本加法单元，支持 <u>1 位的加法运算</u>

* 实现

  1. **本位和**：$\mathrm{S_i}=\mathrm{A_i}\oplus\mathrm{B_i}\oplus\mathrm{C_i}$
  2. **高位进位**：$C_i=A_i B_i+(A_i\oplus B_i) C_{i-1}$

##### 并行加法器

* **串行进位**

  n 个 FA 相连得到 n 位加法器，支持 <u>n 位并行加</u>

  进位信息串行产生，<u>速度慢</u>
* **并行进位**

  在串行进位基础上优化增加 **CLA（超前进位部件）**

  进位信息并行产生，<u>速度快，相互进位没有依赖关系</u>

##### 带标志位加法器

能够进行有符号整数加减运算

* **OF（Over Flag）溢出标志**

  判断<u>带符号数运算</u>​<span data-type="text" id="">是否溢出</span>，1 溢出

  $OF=C_{n}\oplus C_{n-1}$
* **SF（Sign FLag）符号标志**

  判断运算结果正负性，1 为负

  $SF$=<u>补码运算结果最高位</u>
* **ZF（Zero Flag）零标志**

  判断结果是否为零,1 为零

  $ZF=\overline{S_{n}+\cdots+S_{2}+S_{1}}$
* **CF（Carry Flag）进位/借位标志**

  判断<u>无符号数运算</u>是否溢出，1 溢出

  $CF=C_{\mathrm{out}}^{}\oplus C_{\mathrm{in}}^{}=C_{\mathrm{n}}^{}\oplus C_0$

#### 算术逻辑单元（ALU）

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132007671.png)​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408132019744.png)​

* CPU 的核心是 ALU，<u>ALU 的核心是</u>​<u>**加法器，ALU 主要进行算术运算和逻辑运算**</u>
* ALUop 发出控制信号决定 ALU 的处理操作，<u>支持 k 种功能</u>，则控制信号位数 $\mathrm{m}\geq[\log_{2}k] bit$
* 发出控制信号后，由一个 <span data-type="text" id="">MUX</span> 选择输出某种操作结果
* <u>ALU 的运算位数决定了计算机的</u>​<span data-type="text" id="">机器字长</span>
* 标志位表示运算结果特征，送入 **PSW 程序状态字寄存器**中保存（**FR 标志寄存器**）

## 定点数的表示和运算

### 定点数的移位运算

#### 算术移位

* **原码的算术移位**

  <u>符号位不变，数值位整体移动</u>

  * **右移**

    <u>高位补 0，低位舍弃</u>

    <u>**舍弃 0**</u>​<u>，相当于 ÷2</u>；<u>**舍弃 1**</u>​<u>，则丢失精度</u>

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240815193514-3bkxixp.png)​

    即图中最右侧 1 移位后其位权为 2<sup>-1</sup>，被舍弃，丢失 1/2
  * **左移**

    <u>低位补 0，高位舍弃</u>

    **<u>舍弃 0</u>**​<u>，相当于 x2；</u>​**<u>舍弃 1</u>**​<u>，产生严重误差</u>

    和右移同理，高位舍弃 1 的位权过大，故误差严重
* **反码算术移位**

  * **正数**与原码相同
  * **负数**补位使用 1，其他相同
* <span data-type="text" id="">补码</span>​**算术移位**

  * **正数**与原码相同
  * **负数**

    * **右移**（同反码）：<u>高位补 1，低位舍弃</u>
    * **左移**（同原码）：<u>低位补 0，高位舍弃</u>

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408151953587.png)​

||码|添补|
| :-----------------------------: | :-----------------------------: | :----: |
|正数|原、补、反|0|
|负数|原码|0|
||补码|左移 0|
|||右移 1|
||反码|1|

#### 逻辑移位

视为<u>无符号数移位</u>

左移，低位补 0

右移，高位补 0

#### 循环移位

* **不带进位位**

  首尾相接移位
* **带进位位**

  ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408152019835.png)​

### 定点数加减运算

#### 原码加减

**同号加法**，取绝对值相加，保持符号不变

**异号加法**，取绝对值大者-小者，符号同大者

减法运算将<u>“减数”取反转为加法</u>

#### 补码加减

直接将符号位和数值位一起按二进制规则运算

溢出高位舍弃

补码减法<span data-type="text" id="">转变为加法</span>进行运算

#### 补码加法**溢出**

* **上溢**

  结果超过 +127

  正 + 正=负
* **下溢**

  结果小于-128

  负 + 负=正

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408161525625.png)​

如三位补码，当计算 2+2 时，010+010=100（2+2=-4），即从 2 开始沿数轴移动两格得到-4

#### **溢出判断**

**符号位发生改变即溢出**

1. **一位符号法**

   依据正 + 正=负以及负 + 负=正判断

   $V=A_{\mathrm{S}}B_{\mathrm{S}}\overline{S_{\mathrm{S}}}+\overline{A_{\mathrm{S}}}\overline{B_{\mathrm{S}}}S_{\mathrm{S}}$

   V=0，无溢出

   V=1，溢出
2. **一位符号由数据位进位情况判断**

   分别记录符号位进位、最高数值位进位，<span data-type="text" id="">异或判断</span>

   上溢：0、1

   下溢：1、0
3. **双符号位法（模 4 补码）**

   正数为 00，负数为 11

   当两位数不同时发生溢出，<u>异或判断</u>

   此时第一位表示正确的正负性，第二位表示错误得到的正负性

   上溢：01

   下溢：10

   双符号位只有在<u>计算时复制一位符号</u>，存储时**不会增加占用**

#### 补码加减的机器运算

加法直接相加，溢出舍弃

<u>减法需要转换为加法</u>计算，<u>**将“减数”的全部位取反 +1**</u>

> 转换原理：
>
> 计算机中 8 位二进制数，其表示范围为 0~255
>
> 两个 8 位二进制数相加，<u>超过 8 位的部分将被硬件舍弃</u>，也即**对原结果进行了 %2**​<sup>**8**</sup>
>
> 1011 1100 (188)<sub>10</sub> +
>
> 0100 0110 (70)<sub>10</sub> =
>
> ~~1~~ 0000 0010 (258)<sub>10</sub> 舍去首位 1
>
> <u>0000 0010 (2)</u>​<sub><u>10</u></sub>   即结果为 2，258  **% 2**​<sup>**8**</sup> = 2
>
> 合理利用溢出舍去的特性，可以将减法变为加法
>
> 十进制下，188 - **80** = 108 在模 2<sup>8</sup> 意义下转变为加法即 ( 188 + **176** )% 256 = 108
>
> <u>利用硬件的自然溢出即可将减法转变为加法</u>
>
> 1011 1100 -        1011 1100 +
>
> **0101 0000** =        **1011 0000** =
>
> 0110 1100        1 <u>0110 1100</u>
>
> **80** + **176** = 256 转变方法即<u>**将“减数”的全部位取反 +1**</u>
>
> 0101 0000 取反
>
> 1010 1111 +1
>
> **1011 0000**

> ​#408背诵#​  
> 问：<u>有符号整数</u>加减与<u>无符号整数</u>加减<u>使用同一电路运算</u>的理由
>
> 答：
>
> n 位加法器实现的是 %2<sup>n</sup> 无符号整数加法运算
>
> 对于<u>无符号整数</u>a 和 b
>
> a+b 可以直接用加法器实现  
> a-b 即 a-b= a+[-b]<sub>补</sub>（%2<sup>n</sup>)
>
> 所以 n 位无符号整数加减运算可在 n 位加法器中实现
>
> ---
>
> 对于<u>有符号整数</u>a 和 b
>
> 用补码表示，补码加减运算公式为：
>
> [a+b]<sub>补</sub>=[a]<sub>补</sub> +[b]<sub>补</sub>（%2<sup>n</sup>)  
> [a-b]<sub>补</sub>=[a]<sub>补</sub> +[-b]<sub>补</sub>（%2<sup>n</sup>)
>
> 所以 n 位有符号整数加减运算可在 n 位加法器中实现

* **溢出判断**

  * **加法**

    产生进位 1，溢出
  * **减法**

    转为加法时，产生进位 0，溢出

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240816204123-xen7jd2.png)​

注意：补码减法所谓减数 **“取反加一”，在电路中为两步操作**

通过多路选择器 + 非运算电路，同时在 MUX 输入原值与取反值

使用来自**低位进位 Cin** 控制加减法，为 1 时允许取反值经过 MUX，同时将 Cin 的 +1 视为进位加入取反值

即实现**取反加一**

### 定点数乘除运算

**考题中，常使用乘除运算考察移位与数据表示范围**

#### 乘法运算基本原理

0.1101 × 0.1011

(被乘数)  $0.1101=1101\times2^{-4}$

(乘数)    $0.1011=1\times2^{-1}+0\times2^{-2}+1\times2^{-3}+1\times2^{-4}$

$0.1101\times0.1011=(1101\times1\times{\color{Red} 2^{-8}} )+(1101\times1\times{\color{Red} 2^{-7}} )+(1101\times0\times{\color{Red} 2^{-6}} )+(1101\times1\times{\color{Red} 2^{-5}} )$

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240820142628-9fwhpqf.png)​

> ​#408背诵#​
>
> 问：为什么计算机没有乘法指令也能进行乘法运算
>
> 答：乘法可以转换为加法和移位的循环运算

#### 原码一位乘法

* 符号位与数值位分开计算
* 乘积符号 = 两数<u>符号位异或（同号正，异号负）</u>
* 乘积数值 = 两数<u>绝对值相乘</u>

初始<span data-type="text" id="">运算器</span>存储如下所示

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201438050.png "图一，初始情况")​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201442432.png "图二，ACC+X后右移一位")​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201444663.png "图三，手算过程")​

* MQ 灰色为<u>当前参与运算的位</u>

  * 若为 1，ACC 加被乘数
  * 若为 0，ACC 加 0
* ACC 加和后，ACC 与 MQ <u>整体右移一位（逻辑移位）</u>

  如图二，此时灰色部分 1 即为乘数第二个参与运算的数字

  即对应手算中第二步错位加法

  ~~0~~01101 +

  01101
* 重复运算步骤

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201450140.png "最终运算结果")​

#### 补码一位乘法

* **与原码一位乘法对比**

  1. MQ 中最低位为辅助位，其上一位为当前计算位
  2. MQ 多一辅助位，因此 ACC、X 均多一位，采用<span data-type="text" id="">双符号位</span>
  3. 进行加法运算时，辅助位-计算位=

     * 1，ACC + X 补码
     * 0，ACC + 0
     * -1，ACC + -X 补码
  4. 移位使用**补码算术右移**
  5. 符号位参与计算

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201507386.png "-0.1101 × +0.1011")​

#### 除法运算基本原理

**x ÷ y = a...b  ——&gt;  x = ay + b**

0.211 ÷ 0.985 = 0.214...0.00021

(除数 y) $0.214=2\times10^{-1}+1\times10^{-2}+4\times10^{-3}$

(商 a)   $0.985=985\times10^{-3}$

$a\times y=0.985\times0.214=(985\times2\times10^{-4})+(985\times1\times10^{-5})+(985\times4\times10^{-6})=0.21079\\\qquad\qquad\qquad\qquad\qquad=0.1970\qquad\qquad+0.00985\qquad\qquad+0.00394$

即商的位拆分逐个乘除数，尽可能匹配上一步剩余的余数

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201636677.png)​

#### 原码除法——恢复余数法

* 符号位与数值位分开计算
* **商符号** = 两数<u>符号位异或（同号正，异号负）</u>
* **商数值** = 两数<u>绝对值除法</u>

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408201707718.png "图一，运算器初始值")​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408202205608.png "图二，最终结果")​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240820214923-hfogo96.png)​

1. x÷y
2. ACC÷X，计算机首先尝试商 1，即灰色位为 1

   ACC-=[y]<sub>补</sub> = ACC+=[-y]<sub>补</sub>

   * 若**结果为正**，进行 3.
   * 若**结果为负**

     ACC+=[y]<sub>补</sub>，将 ACC 恢复为商 0 结果，灰色位 0，进行 3.
3. ACC 与 MQ 整体“**算术左移**”，重复 2.

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408202207776.png)​

<u>手算时，若商 1 时余数为负数，改为商 0，将该</u>​<u>**负数余数左移 1 位 + 余数**</u>​<u>即可得到下一步余数</u>

#### 原码除法——加减交替法

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211321218.png)​

符号位最后异或得到

**定点小数无法表示大于 1 的数，因此规定定点数除法被除数小于除数**

使用加减交替法时，若**第一个商为 1**，即被除数更大，将直接停止计算

#### 补码除法——加减交替法

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211317857.png)​

## 浮点数的表示和运算

### 浮点数的表示

#### 浮点数的表示

由**尾数，阶码**表示的小数

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211534165.png "浮点数计算机表示")​

${\color{Red} 0} ,{\color{Brown} 01}  ; {\color{orange} 1 } .{\color{Green} 1001}$

${\color{Red} 阶符 } \ {\color{Brown} 阶码数值}  \ {\color{Orange} 数符}  \ {\color{Green} 尾数数值}$

* **阶码**

  用补码或移码表示的<u>定点整数</u>

  反映浮点数表示范围，小数点实际位置

  * **阶符**

    表示小数点的移动方向
* **尾数**

  用原码或补码表示的<u>定点小数</u>

  位数反映浮点数精度

  * **数符**

    表示浮点数的正负

> 3.026×10<sup>+11</sup> 记为 +11 +3.026
>
> -3.026×10<sup>-5</sup> 记为-5 -3.026
>
> ---
>
> 对于二进制补码表示的浮点数
>
> 真值-0.111=-1.11×2<sup>+1</sup> 记为 0,01 ; 1.1001
>
> 阶码 0,01 表示真值 +1
>
> 尾数 1.1001 表示真值-0.0111
>
> 即对尾数算术左移 1 位-0.0111 -> -0.111

对于科学计数法表示的浮点数，一般要求其<u>**尾数最高数值位必须为有效值**</u>​<u>，如下</u>

> 对于补码 0,10；0.0100 1
>
> 尾数 0.<u>0</u>1001，首位为 0，此时浪费一位存储空间存储 0，阶码真值=+2
>
> 对于补码 0,01；0.1001
>
> 尾数 0.1001，阶码真值=+1，此时两个补码表示的浮点数数值相同，但是后者可以用<u>更少的位数表示</u>

#### 浮点数规格化

**规定尾数最高数值位必须为有效值（不为 0）**

* **左规**

  运算结果非规格化时

  尾数左移一位，阶码-1
* **右规**

  计算结果发生溢出（采用双符号位时可挽救溢出）

  尾数右移一位，阶码 +1

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211604920.png)​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211607234.png)​

* 规格化**原码尾数**

  尾数最高位**一定为 1**
* 规格化**补码尾数**

  **符号位与最高位数值相反**

  注意<span data-type="text" id="">补码算术移位</span>规则

#### IEEE754 浮点数

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211700133.png)​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211712358.png)​

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202408211700320.png)​

* **注意**

  * IEEE 标准中，将<u>数符放在最前</u>，同时<u>阶码使用移码</u>，<u>尾数使用原码</u>
  * 同时<u>默认该标准表示的数为</u>​<u>**规约数**</u>，二进制真值为 1.M × 2<sup>x</sup>，即**隐含一首位 1**
  * *阶码真值=阶码移码-偏移量*
  * 取 2<sup>n-1</sup>-1 偏置值时，**全 1 与全 0 阶码不作为规约数**
  * 短浮点数的真值：$(-1)^s\times1.M\times2^{E-127}$

>  **(-0.75)**​<sub>**10**</sub>​**转 IEEE754 单精度浮点数**
>
> (-0.75)<sub>10</sub> =转二进制= (-0.11)<sub>2</sub> =规格化= (-1.1)<sub>2</sub>×2<sup>-1</sup>
>
> 数符=1
>
> 尾数=.10000....(首位 1 隐含)
>
> 阶码真值=-1
>
> 偏移量=127
>
> 阶码移码=阶码真值 + 偏移量 = -1 + 0111 1111 = 0111 1110
> 或=-1+127=126=0111 1110
>
> 即 <u>1</u> <u>01111110</u> <u>100000...</u>

> **IEEE754 单精度浮点数 CO A0 00 00 H 转十进制**
>
> CO A0 00 00 H = 1 10000001 01000...
>
> 数符：-
>
> 尾数：(1.01)<sub>2</sub>=(1.25)<sub>10</sub>
>
> 阶码真值=阶码移码-偏移量=129-127=(2)<sub>10</sub>
>
> 浮点数真值= (-1.01)<sub>2</sub> × 2<sup>2</sup> \= -1.25 × 2<sup>2</sup> \= - 5.0

当阶码 E 全为 0，尾数 M 不全为 0 时，表示**非规约小数**

此时**尾数隐含首位为 0**，阶码真值固定-126

|形式|阶码|尾数|
| ------| -----| ------|
|零|0|0|
|非规约|0|0<=x<1|
|规约|1~2<sup>E</sup>-1|1<=x<2|
|无穷|2<sup>E</sup>-1|0|
|NaN|2<sup>E</sup>-1|!0|

|类别|正负号|实际指数|偏置后阶码|阶码域|尾数域|数值|
| ----------| ------| --------| ----------| ---------| ----------------------------| ----|
|0|0|-127|0|0000 0000|000 0000 0000 0000 0000 0000|+0.0|
|-0|1|-127|0|0000 0000|000 0000 0000 0000 0000 0000|-0.0|
|1|0|0|127|0111 1111|000 0000 0000 0000 0000 0000|+1.0|
|-1|1|0|127|0111 1111|000 0000 0000 0000 0000 0000|-1.0|
|最小规约数|绝对值|-126|1|0000 0001|000 0000 0000 0000 0000 0000|$1.0\times2^{1-127}=1.0\times2^{-126}$​|
|最大规约数|绝对值|127|254|1111 1110|111 1111 1111 1111 1111 1111|$1.11...1\times2^{254-127}=(2-2^{-23})\times2^{127}$​|
|+∞|0|128|255|1111 1111|000 0000 0000 0000 0000 0000|+∞|
|-∞|1|128|255|1111 1111|000 0000 0000 0000 0000 0000|-∞|
|NaN|——|128|255|1111 1111|非全 0|NaN|

|类别|正负号|实际指数|偏置后阶码|阶码域|尾数域|数值|
| ------------| ------| --------| ----------| ---------| ----------------------------| ----|
|最小非规约数|绝对值|-126|0|0000 0000|000 0000 0000 0000 0000 0001|$0.000...1\times2^{0-126}=2^{-23}\times2^{-126}$​|
|中间非规约数|绝对值<br />|-126|0|0000 0000|100 0000 0000 0000 0000 0000|$2^{-1}\times2^{-126}$​|
|最大非规约数|绝对值|-126|0|0000 0000|111 1111 1111 1111 1111 1111|$0.111...1\times2^{0-126}=(1-2^{-23})\times2^{-126}$​|

### 浮点数的运算

#### 加减运算

1. **转换**

   注意阶码和尾数的表示码
2. **对阶**

   小阶向大阶靠齐（算术右移即可）
3. **尾数加减**

   双符号位表示尾数，挽救尾数溢出
4. <span data-type="text" id="">规格化</span>
5. **舍入**

   * **0 舍 1 入法**

     右规时，若溢出 0，舍去

     溢出 1，尾数末位 +1，若又溢出，则继续右规
   * **恒置 1 法**

     使右移后尾数末尾恒为 1
6. **判断溢出**

   规格化后，若阶码上溢，异常，下溢视为机器 0

浮点数运算通常不会直接使用 IEEE754 标准，也即<u>无首位隐含</u>

> 十进制数 X=-5/256、Y=+59/1024，补码运算 X-Y
> 阶符 2 位，阶码 3 位，<u>数符 2 位</u>，尾数 9 位
>
> 1. 转换
>
>    X：-(5 × 1/256) -> -(101 × 2<sup>-8</sup>) -> -(0.101 × 2<sup>-5</sup>) -> <u>-(0.101 × 2</u>​<sup><u>-101</u></sup>​<u>)</u> -> 11.011;11.011000000
>
>    Y：+(59 × 1/1024) -> +(111011 × 2<sup>-10</sup>) -> +(0.111011 × 2<sup>-4</sup>) -> <u>+(0.111011 × 2</u>​<sup><u>-100</u></sup>​<u>)</u> -> 11.100;00.111011000
> 2. 对阶
>
>    X：-(0.101 × 2<sup>-101</sup>) -> -(0.0101 × 2<sup>-100</sup>) -> 11.100;11.101100000
>
>    Y：+(0.111011 × 2<sup>-100</sup>) -> 11.100;00.111011000
> 3. 尾数加减
>
>    Y： 11.100;00.111011000
>    -Y：11.100;11.000101000
>
>    X+(-Y)= 11.100;11.101100000
>
>    + 11.100;11.000101000
>      = 11.100;(1)10.110001000 括号溢出 1
> 4. 规格化
>
>    11.100;(1)10.110001000 右规 1 位
>
>    11.101;11.011000100
> 5. 舍入
> 6. 判断溢出

#### 强制类型转换

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/image-20240822115410-towndjm.png)​

‍

---
title: 进程与线程
slug: process-and-thread-z1wuym
url: /post/process-and-thread-z1wuym.html
date: '2024-04-23 11:57:14+08:00'
lastmod: '2024-04-24 22:24:40+08:00'
toc: true
tags:
  - '408'
  - 操作系统
categories:
  - 提桶跑路笔记
keywords: 408,操作系统
isCJKLanguage: true
---





* 第二章 进程与线程

  * 进程与线程

    * 进程的概念、特征和组成
    * 进程的状态与转换
    * 进程控制
    * 进程的通信
    * 线程和多线程模型
  * CPU调度

    * 调度的概念
    * 调度的实现
    * 调度的目标
    * 进程切换
    * 典型调度算法
  * 同步与互斥

    * 同步与互斥的基本概念
    * 实现临界区互斥的基本方法
    * 互斥锁
    * 信号量
    * 经典同步问题
    * 管程
  * 死锁

    * 死锁的概念
    * 死锁预防
    * 死锁避免
    * 死锁检测和解除

## 进程和线程

### 进程的概念

* **定义**

  * 是程序（进程实体）的一次<u>执行运行过程</u>
  * 是具有独立功能的程序在一个数据集合上运行的过程
  * 是系统进行<u>资源分配和调度</u>的一个<u>独立单位</u>
* **特征**

  1. **动态性**

      进程具有一定<u>生命周期</u>，能够创建活动暂停终止，动态性是其<u>最基本特征</u>
  2. **并发性**

      多个进程能够在一段时间内同时运行
  3. **独立性**

      进程是独立运行、独立获得资源、独立接受调度的基本单位
  4. **异步性**

      进程的相互制约导致进程按各自独立不可预知的速度一起推进，导致结果的不可再现性
* **组成**

  1. **进程控制块**（Process Control Block,PCB）

      <u>进程存在的唯一标志</u>，在进程创建时新建PCB，进程结束时删除PCB

      * PCB包含信息：

        1. **进程描述信息**

            * **进程标识符**PID：每个进程都有一个唯一的标识符
            * **用户标识符**UID：标识进程归属的用户，用于保护和共享服务
        2. **进程控制和管理信息**

            * **进程当前状态**
            * **进程优先级**
        3. **资源分配清单**

            * 有关<u>内存地址空间</u>或<u>虚拟地址空间</u>的信息
            * <u>打开文件的列表</u>和所使用的<u>I/O设备信息</u>
        4. **CPU相关信息**

            * CPU中各寄存器的值
      * 组织PCB：

        * **链接方式**

          统一状态的PCB链成队列，如就绪队列阻塞队列，也可以将阻塞态进程PCB依据原因排成多个阻塞队列
        * **索引方式**

          统一状态的进程组织在索引表中，如就绪索引表、阻塞索引表
  2. **程序段**

      能够被进程调度程序调度到CPU执行的<u>程序代码段</u>，<u>多个进程可以运行同一个程序</u>，即程序是对象，进程是对象的实例
  3. **数据段**

      进程对应程序加工处理的原始数据

      程序执行时产生的中间或最终结果

### 进程的状态与转换

#### 进程的状态

1. **运行态Running**

    该时刻进程占用CPU
2. **就绪态Ready**

    进程获得了除CPU外的一切所需资源，一旦得到CPU，就可以立即运行
3. **阻塞态Blocked**

    该进程正在<u>等待某一事件发生（等待资源分配或等待I/O）</u>而暂停运行，即使具备CPU资源也无法运行
4. **创建态New**

    进程正在被创建时的状态
5. **结束态Exit**

    进程正在从系统中消失时的状态

#### 状态的转换

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404241507762.png)​

* **就绪态--&gt;运行态**

  * 进程被调度，获得CPU资源（分派CPU时间片）
* **运行态--&gt;就绪态**

  * <u>时间片用完</u>
  * 高优先级程序进程就绪时，调度程序将正在执行的进程转为就绪
* **运行态--&gt;阻塞态**

  **主动行为**，进程以系统调用的方式请求OS提供服务，或等待某一事件发生

  * 进程请求某一资源的使用和分配
  * 等待某一事件发生（I/O操作的完成）
* **阻塞态--&gt;就绪态**

  **被动行为**，需要其他相关进程发送唤醒语句

  * 中断结束或I/O操作结束

### 进程控制

操作系统中使用原语控制进程的创建、终止、阻塞、唤醒

#### 进程创建

* 引起事件

  * 用户登录系统
  * 作业调度
  * 系统提供服务
  * 用户程序应用请求
  * 父进程创建子进程

    子进程可以继承父进程的资源，被撤销时返还资源

    父进程撤销，子进程也被撤销
* 创建进程的过程

  1. 申请空白PCB
  2. 向PCB填写控制和管理进程的信息，如唯一标识
  3. 为该进程分配运行所需资源
  4. PCB插入就绪队列，等待调度运行

#### 进程终止

* 引起事件

  * **正常结束**
  * **异常结束**

    程序运行时发生了<u>异常事件</u>无法继续运行

    存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O 故障等
  * **外界干预**

    进程应外界请求终止运行

    如操作员或操作系统干预、父进程请求和父进程终止

  在Linux中父进程被终止，则子进程成为**<u>孤儿进程</u>**
* 进程终止的过程

  1. 查找需要终止进程的PCB
  2. 若处于执行状态则立刻终止，释放其CPU资源
  3. 若具有子进程，子进程交给1号进程（kernel_init）接管，避免孤儿进程
  4. 进程拥有的全部资源归还
  5. 将PCB由队列删除

#### 进程阻塞

* 引起事件

  进程必须等待某一事件完成时，可以<u>调用阻塞语句</u>使自身阻塞等待，<u>一旦被阻塞等待，只能由其他进程唤醒</u>

  * 当进程需要等待某事件完成时
  * 请求系统资源失败
  * 新数据尚未到达，或没有新任务
* 阻塞进程的过程

  1. 找到被阻塞进程<u>标识号对应的PCB</u>
  2. 若处于运行态，则保护现场并将其转换为阻塞态
  3. 将PCB加入到阻塞队列中

#### 进程唤醒

* 引起事件

  进程等待的事件完成后，由其他进程发送消息唤醒该进程，<u>进程不可能自我唤醒</u>

  * 由于等待I/O设备阻塞时，需要由释放该I/O设备的进程发送唤醒语句唤醒
  * 由于等待数据阻塞时，由提供数据的进程发送唤醒语句唤醒
  * ...
* 唤醒进程的过程

  * 在阻塞队列中找到需唤醒队列的PCB
  * 移出阻塞队列，由阻塞态转换为就绪态
  * 插入就绪队列，等待调度

### 进程的通信

指进程之间的信息交换，低级通信方式使用PV操作，<u>高级通信方式</u>主要有三类

#### 共享存储

两个通信进程之间存在一块可以直接访问的<u>共享空间</u>

进程对共享空间读写时，需要使用<u>同步互斥工具</u>控制共享空间读写

* **低级共享**：基于<u>数据结构</u>的共享
* **高级共享**：基于<u>存储区</u>共享

操作系统为通信进程提供可共享使用的空间和同步互斥工具，数据交换指令由用户使用读写指令完成

#### 消息传递

若不能使用共享存储，则必须利用操作系统提供的消息传递实现进程通信

进程间数据交互以格式化的<u>消息</u>为单位，进程通过发送消息和接收消息两个原语进行数据交换

* 特点

  * <u>隐藏了通信实现细节</u>，实现由操作系统完成
  * <u>不存在中间部分</u>，通信过程对用户透明，简化了通讯程序的设计

微内核与服务器之间的通信即采用了消息传递机制

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404242135984.png "共享存储与消息传递")​

#### 管道通信

* **定义**

  **管道**是一个特殊共享文件（pipe文件），管道中的数据<u>**先进先出**</u>

  管道<u>不满</u>，写进程即可一直写入数据；管道<u>非空</u>，读进程即可一直读取数据
* 管道机制必须提供的协调能力

  1. **互斥**：当一个进程对管道进行读写时，其他进程<u>必须等待</u>
  2. **同步**：

      * 写进程写入一定量数据到管道后，写进程阻塞，直到读进程读取数据后将写进程唤醒
      * 读进程将管道数据读空后，读进程阻塞，直到写进程写入数据到管道后将读进程唤醒
      * 即读写进程<u>相互轮流阻塞与唤醒</u>
  3. **确定对方的存在**
* **优点**

  1. <u>管道大小有所限制</u>

      管道文件是固定大小的缓冲区，Linux中为4KB。缓冲区满时，下一个写操作将被阻塞，等待读操作腾出足够的空间
  2. <u>读进程可以比写进程写入的数据读取的更多</u>

      当缓冲区数据读取完还有读操作没执行完，下一个读操作将被阻塞，等待写操作写入数据
  3. 管道只能由创建进程访问，由于管道属于文件，子进程可以继承父进程的资源，因此子进程也可以继承父进程的管道^（继承后读写关系？）^#疑问#​
* **注意**

  * **<u>普通管道仅允许单向通讯，若需要两个进程双向通信，则需要定义两个管道</u>**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404242152405.png)​

### 线程和多线程模型

#### 线程的概念与特征

#### 线程与进程的比较

#### 线程的属性

#### 线程的状态与转换

#### 线程的组织与控制

#### 线程的实现方式

#### 多线程模型

---
title: 进程与线程
slug: process-and-thread-z1wuym
url: /post/process-and-thread-z1wuym.html
date: '2024-04-23 11:57:14+08:00'
lastmod: '2024-04-24 22:24:40+08:00'
toc: true
tags:
  - '408'
  - 操作系统
categories:
  - 提桶跑路笔记
keywords: 408,操作系统
isCJKLanguage: true
---





* 第二章 进程与线程

  * 进程与线程

    * 进程的概念、特征和组成
    * 进程的状态与转换
    * 进程控制
    * 进程的通信
    * 线程和多线程模型
  * CPU调度

    * 调度的概念
    * 调度的实现
    * 调度的目标
    * 进程切换
    * 典型调度算法
  * 同步与互斥

    * 同步与互斥的基本概念
    * 实现临界区互斥的基本方法
    * 互斥锁
    * 信号量
    * 经典同步问题
    * 管程
  * 死锁

    * 死锁的概念
    * 死锁预防
    * 死锁避免
    * 死锁检测和解除

## 进程和线程

### 进程的概念

* **定义**

  * 是程序（进程实体）的一次<u>执行运行过程</u>
  * 是具有独立功能的程序在一个数据集合上运行的过程
  * 是系统进行<u>资源分配和调度</u>的一个<u>独立单位</u>
* **特征**

  1. **动态性**

      进程具有一定<u>生命周期</u>，能够创建活动暂停终止，动态性是其<u>最基本特征</u>
  2. **并发性**

      多个进程能够在一段时间内同时运行
  3. **独立性**

      进程是独立运行、独立获得资源、独立接受调度的基本单位
  4. **异步性**

      进程的相互制约导致进程按各自独立不可预知的速度一起推进，导致结果的不可再现性
* **组成**

  1. **进程控制块**（Process Control Block,PCB）

      <u>进程存在的唯一标志</u>，在进程创建时新建PCB，进程结束时删除PCB

      * PCB包含信息：

        1. **进程描述信息**

            * **进程标识符**PID：每个进程都有一个唯一的标识符
            * **用户标识符**UID：标识进程归属的用户，用于保护和共享服务
        2. **进程控制和管理信息**

            * **进程当前状态**
            * **进程优先级**
        3. **资源分配清单**

            * 有关<u>内存地址空间</u>或<u>虚拟地址空间</u>的信息
            * <u>打开文件的列表</u>和所使用的<u>I/O设备信息</u>
        4. **CPU相关信息**

            * CPU中各寄存器的值
      * 组织PCB：

        * **链接方式**

          统一状态的PCB链成队列，如就绪队列阻塞队列，也可以将阻塞态进程PCB依据原因排成多个阻塞队列
        * **索引方式**

          统一状态的进程组织在索引表中，如就绪索引表、阻塞索引表
  2. **程序段**

      能够被进程调度程序调度到CPU执行的<u>程序代码段</u>，<u>多个进程可以运行同一个程序</u>，即程序是对象，进程是对象的实例
  3. **数据段**

      进程对应程序加工处理的原始数据

      程序执行时产生的中间或最终结果

### 进程的状态与转换

#### 进程的状态

1. **运行态Running**

    该时刻进程占用CPU
2. **就绪态Ready**

    进程获得了除CPU外的一切所需资源，一旦得到CPU，就可以立即运行
3. **阻塞态Blocked**

    该进程正在<u>等待某一事件发生（等待资源分配或等待I/O）</u>而暂停运行，即使具备CPU资源也无法运行
4. **创建态New**

    进程正在被创建时的状态
5. **结束态Exit**

    进程正在从系统中消失时的状态

#### 状态的转换

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404241507762.png)​

* **就绪态--&gt;运行态**

  * 进程被调度，获得CPU资源（分派CPU时间片）
* **运行态--&gt;就绪态**

  * <u>时间片用完</u>
  * 高优先级程序进程就绪时，调度程序将正在执行的进程转为就绪
* **运行态--&gt;阻塞态**

  **主动行为**，进程以系统调用的方式请求OS提供服务，或等待某一事件发生

  * 进程请求某一资源的使用和分配
  * 等待某一事件发生（I/O操作的完成）
* **阻塞态--&gt;就绪态**

  **被动行为**，需要其他相关进程发送唤醒语句

  * 中断结束或I/O操作结束

### 进程控制

操作系统中使用原语控制进程的创建、终止、阻塞、唤醒

#### 进程创建

* 引起事件

  * 用户登录系统
  * 作业调度
  * 系统提供服务
  * 用户程序应用请求
  * 父进程创建子进程

    子进程可以继承父进程的资源，被撤销时返还资源

    父进程撤销，子进程也被撤销
* 创建进程的过程

  1. 申请空白PCB
  2. 向PCB填写控制和管理进程的信息，如唯一标识
  3. 为该进程分配运行所需资源
  4. PCB插入就绪队列，等待调度运行

#### 进程终止

* 引起事件

  * **正常结束**
  * **异常结束**

    程序运行时发生了<u>异常事件</u>无法继续运行

    存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O 故障等
  * **外界干预**

    进程应外界请求终止运行

    如操作员或操作系统干预、父进程请求和父进程终止

  在Linux中父进程被终止，则子进程成为**<u>孤儿进程</u>**
* 进程终止的过程

  1. 查找需要终止进程的PCB
  2. 若处于执行状态则立刻终止，释放其CPU资源
  3. 若具有子进程，子进程交给1号进程（kernel_init）接管，避免孤儿进程
  4. 进程拥有的全部资源归还
  5. 将PCB由队列删除

#### 进程阻塞

* 引起事件

  进程必须等待某一事件完成时，可以<u>**主动调用**</u>​<u>阻塞语句</u>使自身阻塞等待，<u>一旦被阻塞等待，只能由其他进程唤醒</u>

  * 当进程需要等待某事件完成时
  * 请求系统资源失败
  * 新数据尚未到达，或没有新任务
* 阻塞进程的过程

  1. 找到被阻塞进程<u>标识号对应的PCB</u>
  2. 若处于运行态，则保护现场并将其转换为阻塞态
  3. 将PCB加入到阻塞队列中

#### 进程唤醒

* 引起事件

  进程等待的事件完成后，由其他进程发送消息唤醒该进程，<u>进程不可能自我唤醒</u>

  * 由于等待I/O设备阻塞时，需要由释放该I/O设备的进程发送唤醒语句唤醒
  * 由于等待数据阻塞时，由提供数据的进程发送唤醒语句唤醒
  * ...
* 唤醒进程的过程

  * 在阻塞队列中找到需唤醒队列的PCB
  * 移出阻塞队列，由阻塞态转换为就绪态
  * 插入就绪队列，等待调度

### 进程的通信

指进程之间的信息交换，低级通信方式使用PV操作，<u>高级通信方式</u>主要有三类

#### 共享存储

两个通信进程之间存在一块可以直接访问的<u>共享空间</u>

进程对共享空间读写时，需要使用<u>同步互斥工具</u>控制共享空间读写

* **低级共享**：基于<u>数据结构</u>的共享
* **高级共享**：基于<u>存储区</u>共享

操作系统为通信进程提供可共享使用的空间和同步互斥工具，数据交换指令由用户使用读写指令完成

#### 消息传递

若不能使用共享存储，则必须利用操作系统提供的消息传递实现进程通信

进程间数据交互以格式化的<u>消息</u>为单位，进程通过发送消息和接收消息两个原语进行数据交换

* 特点

  * <u>隐藏了通信实现细节</u>，实现由操作系统完成
  * <u>不存在中间部分</u>，通信过程对用户透明，简化了通讯程序的设计

微内核与服务器之间的通信即采用了消息传递机制

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404242135984.png "共享存储与消息传递")​

#### 管道通信

* **定义**

  **管道**是一个特殊共享文件（pipe文件），管道中的数据<u>**先进先出**</u>

  管道<u>不满</u>，写进程即可一直写入数据；管道<u>非空</u>，读进程即可一直读取数据
* 管道机制必须提供的协调能力

  1. **互斥**：当一个进程对管道进行读写时，其他进程<u>必须等待</u>
  2. **同步**：

      * 写进程写入一定量数据到管道后，写进程阻塞，直到读进程读取数据后将写进程唤醒
      * 读进程将管道数据读空后，读进程阻塞，直到写进程写入数据到管道后将读进程唤醒
      * 即读写进程<u>相互轮流阻塞与唤醒</u>
  3. **确定对方的存在**
* **优点**

  1. <u>管道大小有所限制</u>

      管道文件是固定大小的缓冲区，Linux中为4KB。缓冲区满时，下一个写操作将被阻塞，等待读操作腾出足够的空间
  2. <u>读进程可以比写进程写入的数据读取的更多</u>

      当缓冲区数据读取完还有读操作没执行完，下一个读操作将被阻塞，等待写操作写入数据
  3. 管道只能由创建进程访问，由于管道属于文件，子进程可以继承父进程的资源，因此子进程也可以继承父进程的管道

      * [ ] 继承之后的管道关系如何
* **注意**

  * **<u>普通管道仅允许单向通讯，若需要两个进程双向通信，则需要定义两个管道</u>**

    ​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404242152405.png)​

### 线程和多线程模型

#### 线程的概念与特征

* **线程**

  * 进程中的一条执行流程，一个基本的CPU执行单元
  * 是进程的一个实体，是被独立调度和分派的基本单位
  * 线程自己<u>不拥有系统资源</u>，与同属一个进程的其他线程<u>共享进程的资源</u>
  * 同一进程中的多个线程可以<u>并发执行</u>且共享相同的地址空间
  * 线程可以<u>创建和撤销另一个进程</u>
  * 线程具有<u>三种基本状态：就绪运行阻塞</u>，状态转换与进程基本一致
* **线程的组成**

  由线程ID、程序计数器、寄存器集合、堆栈组成

引入线程的目的是为了减少程序在<u>并发执行时所付出的时空开销，提高系统并发性能</u>

引入线程后，线程作为CPU的分配单元，而进程作为除CPU外的其他系统资源分配单元

若线程切换发生在一个进程内部，则时空开销比进程切换少，使得更多线程能够参与并发

#### 线程与进程的比较

||进程|线程|
| --| ----------------------------------------------------| --------------------------------------------------------------------------------------------|
|**调度**|无线程系统的基本调度单位，每次调度都进行上下文切换|独立调度基本单位，进程内调度开销小，进程外调度开销大|
|**是什么的单位**|资源分配的基本单位|调度的基本单位|
|**资源**|系统种拥有资源的基本单位|不拥有资源，共享所属进程的资源|
|**独立性**|独立的地址空间和资源，不允许其他进程访问<br />|同进程的不同线程共享进程的地址空间和资源<br />不同进程的线程不可见|
|**系统开销**|创建撤销进程需要分配或回收PCB及其他资源|线程切换只需要保存和设置少量寄存器内容|
|**多处理器系统的支持**|进程只能运行在一个CPU上|多线程进程可将进程的多个线程分配到多个CPU中，各线程同时占用不同的CPU，可缩短进程的处理时间|

* [ ] 什么是上下文切换

#### 线程的组织与控制

* **线程控制块（PCB）**

  与进程类似，每个线程都有一个线程控制块TCB，用于记录控制和管理线程的信息

  1. **线程标识符**
  2. **一组寄存器**

      包括程序计数器、状态寄存器、通用寄存器
  3. **线程运行状态**
  4. **优先级**
  5. **线程专有存储区**

      线程切换时用于保存现场
  6. **堆栈指针**

      过程调用时保存局部变量及返回地址等
* **线程创建**
* **线程终止**

#### 线程的实现方式

* **用户级线程（User-Level Thread, ULT）**

  * **定义**：由用户级线程库函数完成整个进程的管理和调度
  * **模型**：多对一模型
  * **优点**：

    1. TCB由用户线程库函数维护，可用于不支持线程技术的OS
    2. 无需用户态和内核态的切换，速度快
  * **缺点**：

    1. 一个线程阻塞，整个进程都被阻塞
    2. 多线程执行时，实际上是由多个线程按照用户调度程序<u>分配一个时间片，执行慢</u>
    3. 跨进程切换线程需要内核参与
  * **其他**：

    实质上就是由用户自己模拟实现的多线程，一个进程中的多个线程按照用户编写的调度程序分配一个时间片，因此进程中每次只能有一个线程执行，线程执行阻塞命令则整个进程被阻塞
* **内核级线程（Kernel—Level Thread，KLT）**

  * **定义**：线程对应的TCB放在OS中，线程的管理和调度由OS负责
  * **模型**：一对一模型
  * **优点**：

    1. 内核线程发起系统调用被阻塞，不会影响其他内核线程，内核可以调度该进程的其他线程占用CPU
    2. 发挥多CPU的优势，内核能同时调度同一进程中的多个线程并行执行
    3. 内核本身也可以采用多线程技术，提高系统的执行速度和效率
  * **缺点**：

    1. 同一进程的线程切换需要从用户态转到核心态，系统开销较大  
        因为用户进程的线程在用户态运行，线程调度和管理在内核态
* **组合方式**

  * **定义**：内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程
  * **模型**：多对多模型

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404252203518.png)​

#### 多线程模型

||多对一模型|一对一模型|多对多模型|
| --| -------------------------------------------------------------------------------------------------------------| --------------------------------------------------------| ----------------------------------------------------------------------------------------------------|
|**定义**|多个ULT映射到一个KLT|每个ULT映射到一个KLT|n个ULT映射到m个KLT，n>=m|
|**优点**|线程管理在用户空间进行，效率高|一个线程被阻塞，内核调度另一个线程运行，并发能力强|1. 克服了多对一模型的并发度不高的缺点<br />2. 克服了一对一模型一个用户进程占用太多内核线程开销大的缺点|
|**缺点**|1. 一个线程阻塞，其他线程都被阻塞<br />2. 任何时刻只有一个线程能访问内核<br />3. 多个线程不能同时在多个处理机上运行|每创建一个用户线程，就要创建一个对应的内核线程，开销大|<br />|

​![image](https://image-host-pkj.oss-cn-guangzhou.aliyuncs.com/202404252203571.png)​
